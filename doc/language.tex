\def\listingx{\par\begingroup \parskip=0pt \advance \leftskip by 20pt%
              \smallskip\nobreak \thinline\nobreak \smallskip\nobreak
}%
\def\endlistingx{\smallskip \thinline \endgroup
                 \vskip 2pt plus 5pt \goodbreak}%
\def\listfile#1{\listingx\def\dofile{\compactverbatim\input #1}}%

\chapter{A tutorial introduction}

\Small\ is a simple programming language with a syntax reminiscent to the ``C''
programming language. A \Small\ program consists of a set of functions and a
set of variables. The variables are data objects and the functions contain
instructions (called ``statements'') that operate on the data objects or that
perform tasks.

\noindent\marginbox0{Compiling and running scripts: see \xref{p.compiler}}%
The first program in almost any computer language is one that prints a simple
string; printing ``Hello world'' is a classic example. In \Small, the program
would look like:

\xrdef{p.ex.hello}
\bigskip\listfile{../examples/hello.sma}
\verbatim|parskip=0pt|smalltt|Ccode|dofile|endverbatim\endlistingx

In the language specification, the term ``parser''\sidx{Parser} refers to any
implementation that reads and operates on conforming \Small\ programs. A parser
refers to both interpreters or compilers. This manual assumes that you know
how to build and run a \Small\ program; if not, please consult the application
manual (more hints are at \xref{p.compiler}).

A stand-alone \Small\ program starts execution with function |main|. Here, the
function |main| contains only a single instruction, which is printed at the line
below the function head itself. Line breaks and indenting are insignificant;
the invocation of the function |printf| could equally well be on the same line
as the head of function |main|.

The arguments of a function are always enclosed in parentheses. If a function
does not have any arguments, like function |main|, the opening and closing
parentheses are still present. The single argument of the |printf| function is
a string\marginbox0{String literals: \xrefn{p.const.string}},
which must be enclosed in double quotes.

The characters |\n| near the end of the string form an {\it escape
sequence\/}\marginbox0{Escape sequence: \xrefn{p.character.constants}},
in this case they indicate a ``newline'' symbol. When |printf| encounters the
newline escape sequence, it advances the cursor to the first column of the
next line. One has to use the |\n| escape sequence to insert a ``newline''
into the string, because a string may not wrap over multiple lines.

\Small\ separates the language from the function library. Since \Small\ is
designed to be an {\it extension language\/} for applications, the function
set that a \Small\ program has at its disposal depends on the host application.
As a result, the \Small\ {\it language\/} has no intrinsic knowledge of {\it any\/}
function. The |printf| function used, in this first example, must be made known
to the \Small\ parser explicitly. It is assumed, however, that a host application
automatically declares the essential core of its native functions.

\Small\ is a ``case sensitive'' language: upper and lower case letters are considered
to be different letters. It would be an error to spell the function |printf| in
the above example as ``|PrintF|''.

This first example also reveals a few differences between \Small\ and the C language:
\beginlist{1em}\compactlist
\list{\lbullet}
  there is usually no need to include any system-defined ``header file'';
\list{\lbullet}
  semicolons are optional, except when writing multiple statements on one line;
\list{\lbullet}
  when the body of a function is a single instruction, the braces (for a
  compound instruction) are optional;
%\list{\lbullet} \sidx{Escape characters}
%  ``escape characters'' are called ``control characters'' in \Small, and they
%  start with a caret (``|^|'') rather than a backslash (``|\|''), but see
%  also \xref{p.ctrlchar} or the compiler options to change this special %\xref{p.compiler.options}
%  character.
\endlist

\dingbatseparator

Fundamental elements of most programs are calculations, decisions
(conditional execution), iterations (loops) and variables to store input data,
output data and intermediate results. The next program example illustrates
many of these concepts. The program calculates the greatest common divisor of
two values using an algorithm invented by Euclides.\nameidx{Euclides}
\sidx{Greatest Common Divisor}

\codeidx{gcd} \xrdef{p.ex.gcd}
\bigskip\listfile{../examples/gcd.sma}
\verbatim|parskip=0pt|smalltt|Ccode|dofile|endverbatim\endlistingx

When the body of a function contains more than one statement, these statements
must be embodied in braces ---the ``|{|'' and ``|}|'' characters.
\marginbox0{Compound statement: \xrefn{p.stmt.compound}}
This groups the instructions to a single {\it compound statement\/}. The
notion of grouping statements in a compound statement applies as well to the
bodies of |if|--|else| and loop instructions.

\noindent\marginbox{-6}{Data declarations are covered in detail starting at \xref{p.data.declarations}}%
The |new| keyword creates a variable. The name of the variable follows
|new|. It is common, but not imperative, to assign a value to the variable
already at the moment of its creation. Variables must be declared before they
are used in an expression. The |getvalue| function (also part of
the ``console'' function set) reads in a value from the keyboard and returns
the result. Note that \Small\ is a {\it typeless\/} language, all variables
are numeric cells that can hold a signed integral value.

\goodbreak
\noindent\marginbox0{``while'' loop: \xrefn{p.stmt.while}\lbreak ``if--else'': \xrefn{p.stmt.if}}%
Loop instructions, like |while|, repeat a single instruction as long as the
loop condition, the expression between parentheses, is ``true''. To execute
multiple instructions in a loop, again, requires one to group these
in a compound statement. The |if|--|else| instruction has one instruction for
the ``true'' clause and one for the ``false''.

\noindent\marginbox0{Relational operators: \xrefn{p.op.relational}}
The loop condition for the |while| loop is ``|(a != b)|''; the symbol |!=| is
the ``not equal to'' operator. That is, the |if|--|else| instruction is
repeated until |a| equals |b|. It is good practice to indent the
instructions that run under control of another statement, as is done in the
preceding example.

The call to |printf|, near the bottom of the example, differs from how it was
used in the first example (\xref{p.ex.hello}). Here it prints literal text and
the value of a variable (in a user-specified format) at the same time. The |%d|
symbol in the string is a token that indicates the position and the format that
the subsequent argument to function |printf| should be printed. At run time,
the token |%d| is replaced by the value of variable |a| (the second argument
of |printf|).

\dingbatseparator

Next to {\it simple\/} variables with a size of a single cell, \Small\ supports
arrays and symbolic constants, as exemplified in the program below. It displays
a series of prime numbers using the well known \nameidx{Eratosthenes} ``sieve
of Eratosthenes''.\sidx{Prime numbers}

\codeidx{sieve} \xrdef{p.ex.sieve}
\bigskip\listfile{../examples/sieve.sma}
\verbatim|parskip=0pt|smalltt|Ccode|dofile|endverbatim\endlistingx

\noindent\marginbox0{Constant declaration: \xrefn{p.const}}%
When a program or sub-program has some fixed limit built-in, it is good
practice create a symbolic constant for it. In the preceding example, the
symbol |max_primes| is a constant with the value 100. The program uses the
symbol |max_primes| three times after its definition: in the declaration of
the variable |series| and in both |for| loops. If we were to adapt the
program to print all primes below 500, there is now only one line to change.

\noindent\marginbox0{Progressive initiallers: \xrefn{p.progressive.init}}%
Like simple variables, arrays may be initialized upon creation. \Small\ offers
a convenient shorthand to initialize all elements to a fixed value: all
hundred elements of the ``|series|'' array are set to |true| ---without
requiring that the programmer types in the word ``|true|'' a hundred times.
%\marginbox0{Predefined constants: \xrefn{p.predefined.constants}}%
The symbols |true| and |false| are predefined constants.

When a simple variable, like the variables |i| and |j| in the primes sieve
example, is declared in the first expression of a |for| loop, the variable
is valid only inside the loop. Variable declaration has its own rules; it is
not a statement ---although it looks like one.
\marginbox0{``for'' loop: \xrefn{p.stmt.for}}%
One of those rules is that the first expression of a |for| loop may contain a
variable declaration.

\noindent\marginbox0{An overview of all operators: \xrefn{p.operators}}%
Both |for| loops also introduce new operators in their third expression. The
|++| operator increments its operand by one; that is, |++i| is equal to
{\tt i~=~i~+~1}. The |+=| operator adds the expression on its right to the variable
on its left; that is, {\tt j~+=~i} is equal to {\tt j~=~j~+~i}.

The first element in the |series| array is |series[0]|, if the array holds
|max_primes| elements, the last element in the array is |series[max_primes-1]|.
If |max_primes| is 100, the last element, then, is |series[99]|. Accessing
|series[100]| is invalid.

\dingbatseparator

Larger programs separate tasks and operations into functions. Using functions
increases the modularity of programs and functions, when well written, are
portable to other programs. The following example implements a function to
calculate numbers from the Fibonacci series.

\nameidx{Fibonacci} \nameidx{Leonardo of Pisa}
The Fibonacci sequence was discovered by Leonardo ``Fibonacci'' of Pisa, an
Italian mathematician of the 13th century---whose greatest achievement was
popularizing for the Western world the Hindu-Arabic numerals. The Fibonacci
numbers describe a surprising variety of natural phenomena. For example, the
two or three sets of spirals in pineapples, pine cones and sunflowers usually
have consecutive Fibonacci numbers between 5 and 89 as their number of
spirals. The numbers that occur naturally in branching patterns (e.g. that of
plants) are indeed Fibonacci numbers. Finally, although the Fibonacci sequence
is {\it not\/} a geometric sequence, the further the sequence is extended, the
more closely the ratio between successive terms approaches the {\it golden
ratio\/}, of 1.6188\dots that appears so often in art and architecture.\sidx{Golden ratio}

\noindent\marginbox0{``assert'' statement: \xrefn{p.stmt.assert}}%
The |assert| instruction at the top of the |fibonacci| function deserves
explicit mention; it guards against ``impossible'' or invalid conditions.

\xrdef{p.ex.fibonacci}
\codeidx{fibonacci} \sidx{Fibonacci numbers}
\bigskip\listfile{../examples/fib.sma}
\verbatim|parskip=0pt|smalltt|Ccode|dofile|endverbatim\endlistingx

\noindent\marginbox0{Functions: properties \& features: \xrefn{p.functions}}%
The implementation of a user-defined function is not much different than that
of function |main|. Function |fibonacci| shows two new concepts, though: it
receives an input value through a parameter and it returns a value (it has a
``result'').
%??? Calling a user-defined function is similar to calling ``system'' functions like |getvalue|.

Function parameters are declared in the function header; the single parameter
in this example is |n|. Inside the function, a parameter behaves as a local
variable, but one whose value is passed from the outside at the {\it call\/} to
the function.

The |return| statement ends a function and sets the result of the function. It
need not appear at the very end of the function; early exits are permitted.

\dingbatseparator

Dates are a particularly rich source of algorithms and conversion routines,
because the calenders that a date refers to have known such a diversity,
through time and around the world.

\nameidx{Scaliger, Josephus} \sidx{Julian Day number} \sidx{Gregorian calendar}
The ``Julian Day Number'' is attributed to Josephus Scaliger\stdfootnote{There
is some debate on exactly {\sevenit what\/} Josephus Scaliger invented and
{\sevenit who\/} or {\sevenit what\/} he called it after.\par} and it counts the number of days since
November 24, 4714 BC (proleptic Gregorian calendar). Scaliger chose that date
because it marked the coincidence of three well-established cycles: the
28-year Solar Cycle (of the old Julian calendar), the 19-year Metonic Cycle and
the 15-year Indiction Cycle (periodic taxes or governemental requisitions in
ancient Rome), and because no literature or recorded history was known to
predate that particular date in the remote past. Scaliger used this concept
to reconcile dates in historic documents, later astronomers embraced it
to calculate intervals between two events more easily.

Julian Day numbers (sometimes denoted with unit ``\smallcaps{jd}'') should not be confused
with Julian Dates (the number of days since the start of the {\it same\/} year),
or with the Julian calendar that was introduced by Julius Caesar.

Below is a program that calculates the Julian Day number from a date in the
(proleptic) Gregorian calendar, and vice versa. Note that in the proleptic
Gregorian calendar, the first year is 1 AD (Anno Domini) and the
year before that is 1 BC (Before Christ): year zero does not exits! The program
uses negative year values for BC years and positive (non-zero) values for AD
years. The Gregorian calendar was decreed to start on 15 October 1582 by pope
Gregory XIII, which means that earlier dates do not really exist in the
Gregorian calendar. When extending the Gregorian calendar to days before 15
October 1582, we refer to the {\it proleptic\/} Gregorian calendar.

\bigskip\listfile{../examples/julian.sma}
\verbatim|parskip=0pt|smalltt|Ccode|dofile|endverbatim\endlistingx

Function |main| starts with creating variables to hold the day, month and year,
and the calculated Julian Day number. Then it reads in a date ---three calls to
|getvalue|--- and calls function |DateToJulian| to calculate the day number.
After calculating the result, |main| prints the date that you entered and the
Julian Day number for that date. Now, let us focus on function |DateToJulian|\dots

Near the top of function |DateToJulian|, it increments the |year| value if it
is negative; it does this to cope with the absence of a ``zero'' year in the
proleptic Gregorian calendar. In other words, function |DateToJulian| modifies
its function arguments (later, it also modifies |month|). Inside a function,
an argument behaves like a local variable: you may modify it. These
modifications remain local to the function |DateToJulian|, however. Function
|main| passes the values of |d|, |m| and |y| into |DateToJulian|, who maps
them to its function arguments |day|, |month| and |year| respectively.
\marginbox0{``Call by value'' versus ``call by reference'': \xrefn{p.function.args}}%
Although |DateToJulian| modifies |year| and |month|, it does not change |y| and
|m| in function |main|; it only changes local copies of |y| and |m|. This
concept is called ``call by value''. \sidx{Call by value} \sidx{Functions}[call by value]

The example intentionally uses different names for the local variables in the
functions |main| and |DateToJulian|, for the purpose of making the above
explanation easier. Renaming |main|'s variables |d|, |m| and |y| to |day|, |month|
and |year| respectively, does not change the matter: then you just happen to
have two local variables called |day|, two called |month| and two called |year|,
which is perfectly valid in \Small.

The remainder of function |DateToJulian| is, regarding the \Small\ language,
uninteresting arithmetic.

Returning to the second part of the function |main| we see that it now asks
for a day number and calls another function, |JulianToDate|, to find the date
that matches the day number. Function |JulianToDate| is interesting because it
takes one input argument (the Julian Day number) and needs to calculate three
output values, the day, month and year. Alas, a function can only have a
single return value ---that is, a |return| statement in a function may only
containe {\it one\/} expression. To solve this, |JulianToDate| specifically
requests that changes that it makes to some of its function arguments are
copied back to the variables of the caller of the function. Then, in |main|,
the variables that must hold the result of |JulianToDate| are passed as
arguments to |JulianToDate|.

Function |JulianToDate| marks arguments individually for the purpose of
``copying back to caller'' by prefixing the arguments with an |&| symbol.
Arguments with an |&| are copied back, arguments without is are not. ``Copying
back'' is actually not the correct term. An argument tagged with an |&| is
passed to the function in a special way that allows the function to directly
modify the original variable. This is called ``call by reference'' and an
argument that uses it is a ``reference argument''.
\sidx{Reference arguments} \sidx{Call by reference} \sidx{Functions}[call by reference]

In other words, if |main| passes |y| to |JulianToDate| ---who maps it to its
function argument |year|--- and |JulianToDate| changes |year|, then |JulianToDate|
{\it really\/} changes |y|. Only through reference arguments can a function
directly modify a variable that is declared in a different function.

To summarize the use of call-by-value versus call-by-reference: if a function
has one output value, you typically use a |return| statement; if a function
has more output values, you use reference arguments. You may combine the two
inside a single function, for example in a function that returns its
``normal'' output via a reference argument and an error code in its return
value.

\sidx{Date arithmetic}
As an aside, many desktop application use conversions to and from Julian Day
numbers (or varieties of it) to conveniently calculate the number of days
between to dates or to calculate the date that is 90 days from now ---for example.

\dingbatseparator

% ??? Weekday
% * true modulus, no need to replace -2*e by +5*e
% * switch is not fall through; switch in C is a conditional goto, akin to Fortran's calculated labels

\Small\ has no intrinsic ``string'' type; character strings are stored in arrays,
with the convention that the array element behind the last valid character
is zero. Working with strings is therefore equivalent with working with arrays.

Among the simplest of encryption schemes is the one called ``ROT13''
---actually the algorithm is quite ``weak'' from a cryptological point of view.
It is most widely used in public electronic forums (BBSes, Usenet) to hide texts
from casual reading, such as the solution to puzzles or riddles. ROT13 simply
``rotates'' the alphabet by half its length, i.e. 13 characters. It is a
symmetric operation: applying it twice on the same text reveals the original.

\sidx{ROT13 encryption} \codeidx{rot13} \xrdef{p.ex.rot13}
\bigskip\listfile{../examples/rot13.sma}
\verbatim|parskip=0pt|smalltt|Ccode|dofile|endverbatim\endlistingx

In the function header of |rot13|, the parameter ``|string|'' is declared as
an array, but without specifying the size of the array ---there is no value
between the square brackets. When you specify a size for an array in a function
header, it must match the size of the {\it actual\/} parameter in the function
call.\sidx{Actual parameter} \sidx{Parameter}[actual \midtilde]
Omitting the array size specification in the function header removes this
restriction and allows the function to be called with arrays of any size. You
must then have some other means of determining the (maximum) size of the
array. In the case of a string parameter, one can simply search for the zero
terminator.

The |for| loop that walks over the string is typical for string processing
functions. Note that the loop condition is ``|string[index]|''. The rule for
true\slash false conditions in \Small\ is that any value is ``true'', except
zero. That is, when the array cell at |string[index]| is zero, it is ``false''
and the loop aborts.

The ROT13 algorithm rotates only letters; digits, punctuation and special
characters are left unaltered. Additionally, upper and lower case letters must
be handled separately. Inside the |for| loop, two |if| statements filter out
the characters of interest. The way that the second |if| is chained to the
``else'' clause of the first |if| is noteworthy, as it is a typical method of
testing for multiple non-overlapping conditions.

\sidx{Chained relational operators}
\noindent\marginbox0{Relational operators: \xrefn{p.op.relational}}%
Another point of interest are the conditions in the two |if| statements. The
first |if|, for example, holds the condition ``|'a' <= string[index] <= 'z'|'',
which means that the expression is true if (and only if) both |'a' <= string[index]|
{\it and\/} |string[index] <= 'z'| are true. In the combined expression, the
relational operators are said to be ``chained'', as they chain multiple
comparisons in one condition.

\noindent\marginbox0{Escape sequence: \xrefn{p.character.constants}}
Finally, note how the last |printf| in function |main| uses the escape sequence
|\"| to print a double quote. Normally a double quote ends the literal string;
the escape sequence ``|\"|'' inserts a double quote into the string.

% ??? pay attention: function |rot13| modifies its parameter, although the string
%     is {\it not\/} declared as a reference argument. To conserve memory, \Small\
%     {\it always\/} passes arrays by reference. A function that treats an array as an {\it input\/}
%     argument and does not change it, may mark it as ``|const|''

\dingbatseparator

% ??? packed strings

\sidx{Structures}
In a typeless language, we might assign a different purpose to some array
elements than to other elements in the same array. \Small\ supports enumerated
constants with an extension
that allows it to mimic some functionality that other languages implement
with ``structures'' or ``records''.

The example to illustrate enumerations and arrays is longer than previous
\Small\ programs, and it also displays a few other features, such as global
variables and named parameters.

\codeidx{enum} \xrdef{p.ex.queue}%
\bigskip\listfile{../examples/queue.sma}
\verbatim|parskip=0pt|smalltt|Ccode|dofile|endverbatim\endlistingx

\noindent\marginbox0{``enum'' statement: \xrefn{p.enum}}%
Near the top of the program listing is the declaration of the enumeration
|message|. This enumeration defines two constants: |text|, which is zero, and
|priority|, which is 11 (assuming a 32-bit cell). The idea behind an
enumeration is to quickly define a list of symbolic constants without
duplicates. By default, every constant in the list is 1 higher than its
predecessor and the very first constant in the list is zero. However, you may
give an {\it extra\/} increment for a constant so that the successor has a
value of 1 plus that extra increment. The |text| constant specifies an extra
increment of |40 char|.
\marginbox0{``char'' operator: \xrefn{p.op.char}}%
In \Small, |char| is an operator, it returns the number of cells needed to
hold a packed string of the specified number of characters. Assuming a 32-bit
cell and a 8-bit character, 10 cells can hold 40 packed characters.

Immediately at the top of function |main|, a new array variable is declared
with the size of |message|. The symbol |message| is the name of the enumeration.
It is also a constant with the value of the last constant in the enumeration
list plus the optional extra increment for that last element. So in this
example, |message| is 11. That is to say, array |msg| is declared to hold 11
cells.

Further in |main| are two loops. The |for| loop reads strings and priority
values from the console and inserts them in a queue. The |while| loop below
that extracts element by element from the queue and prints the information on
the screen. The point to note, is that the |for| loop stores both the string
and the priority number (an integer) in the same variable |msg|; indeed,
function |main| declares only a single variable. Function |getstring| stores
the message text that you type starting at array |msg[text]| while the
priority value is stored (by an assignment a few lines lower) in
|msg[priority]|. The |printf| function in the |while| loop reads the string
and the value from those positions as well.

At the same time, the |msg| array is an entity on itself: it is passed in its
entirity to function |insert|. That function, near the end, says
``|queue[queueitems] = item|'', where |item| is an array with size |message|
and |queue| is a two-dimensional array that holds |queuesize| elements of size
|message|. The declaration of |queue| and |queuesize| are just above function
|insert|.

\sidx{Priority queue}
The example implements a ``priority queue''. You can insert a number of
messages into the queue and when these messages all have the same priority,
they are extracted from the queue in the same order. However, when the
messages have different priorities, the one with the highest priority comes
out first. The ``intelligence'' for this operation is inside function |insert|:
it first determines the position of the new message to add, then moves a few
messages one position upward to make space for the new message. Function
|extract| simply always retrieves the first element of the queue and shifts all
remaining elements down by one position.

Note that both functions |insert| and |extract| work on two shared variables,
|queue| and |queueitems|. A variable that is declared inside a function, like
variable |msg| in function |main| can only be accessed from within that
function. A ``global variable'' is accessible by {\it all\/} functions, and that
variable is declared outside the scope of any function. Variables must still be
declared before they are used, so |main| cannot access variables |queue| and
|queueitems|, but both |insert| and |extract| can.

Function |extract| returns the messages with the highest priority via its
function argument |item|. That is, it changes its function argument by copying
the first element of the |queue| array into |item|. Function |insert| copies
in the other direction and it does not change its function argument |item|. In
such a case, it is advised to mark the function argument as ``|const|''. This
helps the \Small\ parser to both check for errors and to generate better (more
compact, quicker) code.

\noindent\marginbox0{Named parameters: \xrefn{p.named.parameters}}%
A final remark on this latest sample is the call to |getstring| in function
|main|: note how the parameters are attributed with a decsription. The first
parameter is labeled ``|.string|'', the second ``|.maxlength|'' and the
third ``|.pack|''. Function |getstring| receives ``named parameters'' rather
than positional parameters. The order in which named parameters are listed is
not important. Named parameters are convenient in specifying ---and deciphering---
long parameter lists.

%???
%\sidx{Hand-waving algorithm}
%Function |insert| initially adds the new item to the end of the queue and then
%it uses a clever trick to move it to the proper location. One observation that
%we can make is that if some subrange of an array moves downwards, the subrange
%immediately preceding that one must move upwards. That is, shifting a subrange
%downwards boils down to the same operation as {\it swapping\/} two subranges
%of an array. The goal of the algorithm used here is to swap two ranges, but
%with allocating minimal extra resources (read ``variables'') to do so. To do
%so, the algorithm first reverses the array elements of both subranges
%individually, and then reverses the array elements of both subranges taken
%together. This is called the ``hand-waving'' algorithm.
%
%Shifting ranges in an array up or down with the hand-waving algorithm is
%programmers' folklore from the days of yore, when memory was a scarce resource,
%the CPU was slow enough to do without a layered memory cache, and |goto| was
%considered harmful. Well\dots\ those days are back: scripting languages have
%your programs run out of memory far too quickly, the ``virtual registers'' of
%an abstract machine are hardly faster than system memory, and |goto| is
%{\it still\/} considered harmful.

\dingbatseparator

\sidx{Set operations} \sidx{Intersection (sets)} \sidx{Union (sets)}
A few algorithms are most easily solved with ``set operations'', like intersection,
union and inversion. In the figure below, for example, we want to design an
algorithm that returns us the points that can be reached from some other point
in a specified maximum number of steps. For example, if we ask it to return the
points that can be reached in two steps starting from {\bf B}, the algorithm has
to return {\bf C}, {\bf D}, {\bf E} and {\bf F}, but not {\bf G} because {\bf G}
takes three steps from {\bf B}.

\vskip 3pt plus 3pt\midfigure{pict/sets}{195}{168}~\vskip 3pt plus 3pt\relax
Our approach is to keep, for each point in the graph, the set of other points
that it can reach in {\it one\/} step ---this is the ``|next step|'' set. We
also have a ``|result|'' set that keeps all points that we have found so far. We
start by setting the |result| set equal to the |next step| set for the departure
point. Now we have in the |result| set all points that one can reach in one
step. Then, for every point in our |result| set, we create a union of the
|result| set and the |next step| set for that point. This process is iterated
for a specified number of loops.

An example may clarify the procedure outlined above. When the departure point
is {\bf B}, we start by setting the |result| set to {\bf D} and {\it E} ---these
are the points that one can reach from {\bf B} in one step. Then, we walk
through the |result| set. The first point that we encounter in the set is
{\bf D}, and we check what points can be reached from {\bf D} in one step: these
are {\bf C} and {\bf F}. So we add {\bf C} and {\bf F} to the |result| set. We
knew that the points that can be reached from {\bf D} in one step are {\bf C}
and {\bf F}, because {\bf C} and {\bf F} are in the |next step| set for {\bf D}.
So what we do is to merge the |next step| set for point {\bf D} into the
|result| set. The merge is called a ``union'' in set theory. That handles {\bf D}.
The original |result| set also contained point {\bf E}, but the |next step| set
for {\bf E} is empty, so no more point is added. The new |result| set therefore
now contains {\bf C}, {\bf D}, {\bf E} and {\bf F}.

\sidx{Bitwise operators}
A set is a general purpose container for elements. The only information that a
set holds of an element is whether it is present in the set or not. The order
of elements in a set is insignificant and a set cannot contain the same element
multiple times. The \Small\ language does not provide a ``set'' data type or
operators that work on sets. However, sets with up to 32 elements can be
simulated by bit operations. It takes just one bit to store a ``present/absent''
status and a 32-bit cell can therefore maintain the status for 32 set elements
---provided that each element is assigned a unique bit position.

The relation between set operations and bitwise operations is summarized in the
following table. In the table, an upper case letter stands for a set and a lower
case letter for an element from that set.

~~~~~ \hbox{\vbox{\advance \hsize by -1 in \noindent
{
 \def\!{\tabalign\strut\ }%
 \def\/{&\strut\  }%

 \settabs\+\bf \hskip 1in & \hskip 1.7in & \hskip 1.5in &\cr
\+\bf ~concept & \ \bf ~mathematical notation & \ \bf ~\Small\ expression & \cr \smallskip \hrule
\! intersection \/ $A \cap B$    \/ |A & B|        \/\cr
\! union        \/ $A \cup B$    \/ |A| \vbar\ |B| \/\cr
\! complement   \/ $\overline A$ \/ |~A|           \/\cr
\! empty set    \/ $\varepsilon$ \/ |0|            \/\cr
\! membership   \/ $x \in A$     \/ |(1 << x) & A| \/\cr \hrule
} }}
\vskip 3pt plus 6pt\goodbreak

To test for membership ---that is, to query whether a set holds a particular
element, create a set with just one element and take the intersection.
If the result is |0| (the empty set) the element is not in the set. Bit
numbering starts typically at zero; the lowest bit is bit |0|
and the highest bit in a 32-bit cell is bit |31|. To make a cell with only
bit |7| set, shift the value |1| left by seven ---or in a \Small\ expression:
``|1 << 7|''.

Below is the program that implements the algorithm described earlier to find
all points that can be reached from a specific departure in a given number of
steps. The algorithm is completely in the |findtargets| function.

\xrdef{p.ex.set}
\bigskip\listfile{../examples/set.sma}
\begingroup\catcode`\|=\other\verbatimescapechar\~
\verbatim~parskip=0pt~smalltt~dofile~endverbatim\verbatimescapechar\|\endlistingx
\endgroup

\sidx{Multiplicative increment} \sidx{Bit shifting increment}
\noindent\marginbox0{``enum'' statement: \xrefn{p.enum}}%
The |enum| statement just below the header of the |main| function declares the
constants for the nodes |A| to |G|, but with a twist. Usually, the enum starts
counting from zero; here, the value of the first constant, |A|, is explicitly
set to 1. More noteworthy is the expression ``|(<<= 2)|'' between the |enum|
keyword and the opening brace that starts the constant list: it specifies a
``bit shifting'' increment. By default, every constant in an |enum| list gets a
value that is 1 above its predecessor, but you can specify every successive
constant in an enumeration to have a value that is:
\beginlist{1em}\compactlist
\list{\lbullet}
  its predecessor incremented by any value (not just 1) ---e.g., ``|(+= 5)|'';
\list{\lbullet}
  its predecessor multiplied by any value ---e.g., ``|(*= 3)|'';
\list{\lbullet}
  its predecessor bit-shifted to the left by any value ---e.g., ``|(<<= 1)|'';
\endlist
\sidx{Binary arithmetic}
Note that, in binary arithmetic, shifting left by one bit amounts to the same
as multiplying by two, meaning that ``|(*= 2)|'' and ``|(<<= 1)|'' do the same
thing.

\codeidx{bitcount}
\noindent\marginbox0{``cellbits'' constant: \xrefn{p.predefined.constants}}%
When working with sets, a typical task that pops up is to determine the number
of elements in the set. A straightforward function that does this is below:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
bitcount(set)
    {
    new count = 0
    for (new i = 0; i < cellbits; i++)
        if (set & (1 << i))
            count++
    return count
    }
|endverbatim\endlistingx

With a cell size of 32 bits, this function's loop iterates 32 times to check for
a single bit at each iteration. With a bit of binary arithmetic magic, we can
reduce it to loop only for the number of bits that are ``set''. That is, the
following function iterates only once if the input value has only one bit set:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
bitcount(set)
    {
    new count = 0
    if (set)
        do
            count++
        while ((set = set & (set - 1)))
    return count
    }
|endverbatim\endlistingx

% --for larger sets, you will need to chain a few cells together in an array and perform the bit operations on the array elements in sequence.


\dingbatseparator

\xrdef{p.compiler}
The big hurdle that I have stepped over is how to actually compile the code
snippets presented in this chapter. The reason is that the procedure depends
on the system that you are using: in some applications there is a ``{\tensans Make}''
or ``{\tensans Compile script}'' command button or menu option, whil in other
environments you have to type a command like ``|sc myscript|'' on a command prompt.
If you are using the standard \Small\ toolset, you will find instructions of how
to use the compiler and run-time in the companion booklet ``The \Small\ booklet
--- Implementor's Guide''.

Regardless of the differences in launching the compile, the phenomenon that
results from launching the compile are likely to be very similar between all
systems:
\beginlist{1em}\compactlist
\list{\lbullet}
  either the compile succeeds and produces an executable program ---that may or
  may not run automatically after the compile;
\list{\lbullet}
  or the compile gives a list of warning and error messages.
\endlist

\sidx{Errors}
Mistakes happen and the \Small\ parser tries to catch as many of them as it can.
When you inspect the code that the \Small\ parser complains about, it may on
occasion be rather difficult for you to see why the code is erroneous (or suspicious).
The following hints may help:
\beginlist{1em}
\list{\lbullet}
  Each error or warning number is numbered. You can look up the error message
  with this number in appendix \refcust{Error and warning messages}, along with
  a brief description on what the message really means.
\list{\lbullet}
  If the \Small\ parser produces a list of errors, the {\it first\/} error in
  this list is a true error, but the diagnistic messages below it may not be
  errors at all.

  After the \Small\ parser sees an error, it tries to step over
  it and complete the compilation. However, the stumbling on the error may have
  confused the \Small\ parser so that subsequent legitimate statements are
  misinterpreted and reported as errors too.

  When in doubt, fix the first error and recompile.
\list{\lbullet}
  The \Small\ parser checks only the syntax (spelling\slash grammar), not the
  semantics (i.e.\ the ``meaning'') of the code. When it detects code that does
  not comply to the syntactical rules, there may actually be different ways in
  which the code can be changed to be ``correct'', in the syntactical sense of
  the word ---even though many of these ``corrections'' would lead to non-sensical
  code. The result is, though, that the \Small\ parser may have difficulty to
  precisely locate the error: it does not know what you meant to write. Hence,
  the parser often outputs two line numbers and the error is
  somewhere in the range (between the line numbers).
\list{\lbullet}
  Remember that a program that has no syntactical errors (the \Small\ parser
  accepts it without error \& warning messages) may still have semantical and
  logical errors which the \Small\ parser cannot catch. The |assert| instruction
  (\xref{p.stmt.assert}) is meant to help you catch these ``run-time'' errors.
\endlist

\dingbatseparator
% \vskip 10pt plus 20pt\relax \goodbreak

If you know the C programming language, you will have seen many concepts that
you are familiar with, and a few new ones. If you don't know C, the pace of
this introduction has probably been quite high. Whether you are new to C or
experienced in C, I encourage you to read the following pages carefully. If
you know C or a C-like language, by the way, you may want to consult the chapter
``Pitfalls'' (\xref{p.pitfalls}) first.
This booklet attempts to be both an informal introduction and a (more formal)
language specification at the same time, perhaps succeeding at neither. Since
it is also the {\it standard\/} book on \Small,\stdfootnote{It is no longer the
{\sevenit only\/} book on Small.\par} the focus of this booklet is on being
accurate and complete, rather than being easy to grasp.

The double nature of this booklet shows through in the order at which it
presents the subjects. The larger conceptual parts of the language, variables
and functions, are covered first. The operators, the statements and general
syntax rules follow later ---not that they are less important, but they are
easier to learn, to look up, or to take for granted.


\def\eatvskip{\vskip -\parskip}
\def\itemnb#1:{\list{\bf #1}}
\def\item#1:{\list{\bf #1}\lbreak}


\vfill\eject
\footnotenumber=0%

\chapter{Data and declarations}
\xrdef{p.data.declarations} \sidx[begin]{Data declarations}
\sidx[see]{Variables}{Data declarations}

\Small\ is a typeless language. All data elements are of type ``cell'', and a
cell can hold an integral number. The size of a cell (in bytes) is system
dependent ---usually, a cell is 32-bits.

The keyword |new| declares a new variable. For special declarations, the
keyword |new| is replaced by |static|, |public| or |stock| (see below). A
simple variable declaration creates a variable that occupies one ``cell'' of
data memory. Unless it is explicitly initialized, the value of the new variable
is zero.

A variable declaration may occur:
\beginlist{1em}\compactlist
\list{\lbullet} at any position where a statement would be valid ---local
  variables;
\list{\lbullet} at any position where a function declaration (native function
  declarations) or a function implementation would be valid ---global variables;
\list{\lbullet} in the first expression of a |for| loop instruction ---also
  local variables.
\endlist

\beginlist{35pt}
\item Local declarations: \sidx{Local variables} \sidx{Data declarations}[local \midtilde]
        A local declaration appears inside a compound statement. A local
        variable can only
        be accessed from within the compound statement, and from nested
        compound statements. A declaration in the first expression of a |for|
        loop instruction is also a local declaration.

\item Global declarations: \sidx{Global variables} \sidx{Data declarations}[global \midtilde]
        A global declaration appears outside a function and a global variable
        is accessible to any function. Global data objects can only be
        initialized with constant expressions.
\endlist


\subsection{Static local declarations}
\xrdef{p.static.vars}
\sidx{Static}[variables@\midtilde\ variables]
A local variable is destroyed when the execution leaves the compound block in
which the variable was created. Local variables in a function only exist during
the run time of that function. Each new run of the function creates and
initializes new local variables. When a local variable is declared with
the keyword |static| rather than |new|, the variable remains in existence
after the end of a function. This means that static local variables provide
private, permanent storage that is accessible only from a single function
(or compound block). Like global variables, static local variables can only be
initialized with constant expressions.


\vfill\eject%???
\subsection{Static global declarations}
%\xrdef{p.static.vars}
\sidx{Static}[variables@\midtilde\ variables]
A static global variable behaves the same as a normal global variable, except
that its scope is restricted to the file that the declaration resides in. To
declare a global variable as static, replace the keyword |new| by |static|.


\subsection{Stock declarations}
\xrdef{p.stock.vars} \sidx{Stock}[variables@\midtilde\ variables] \sidx{Data declarations}[stock \midtilde]
\noindent\marginbox0{Stock functions: \xrefn{p.stock.funcs}}%
A global variable may be declared as ``stock''. A stock declaration is one that
the parser may remove or ignore if the variable turns out not to be used in the
program. Stock variables are useful in combination with stock functions.


\subsection{Public declarations}
\xrdef{p.public.vars} \sidx{Public}[variables@\midtilde\ variables] \sidx{Data declarations}[public \midtilde]
Global ``simple'' variables (no arrays) may be declared ``public'' in two ways:
\beginlist{1em}\compactlist
\list{\lbullet}
  declare the variable using the keyword |public| instead of |new|;
\list{\lbullet}
  \sidx{\char64-symbol} %\char64 == @
  start the variable name with the ``@'' symbol.
\endlist

%\noindent\marginbox0{The Abstract Machine interface: \xrefn{p.tools.amx}}%
\sidx{Host application}%
Public variables behave like global variables, with the addition that the
host program can also read and write public variables. A (normal) global
variable can only be accessed by the functions in your script ---the host
program is unaware of them. As such, a host program may require that you
declare a variable with a specific name as ``public'' for special purposes
---such as the most recent error number, or the general program state.


\subsection{Constant variables}
\xrdef{p.const.variable} \sidx{Constants}[``const'' variables]
\noindent\marginbox0{Symbolic constants: \xrefn{p.const}}%
It is sometimes convenient to be able to create a variable that is
initialized once and that may not be modified. Such a variable behaves much
like a symbolic constant, but it still is a variable.

To declare a constant variable, insert the keyword |const| between the keyword
that starts the variable declaration ---|new|, |static|, |public| or |stock|---
and the variable name.

\goodbreak
Examples:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new const address[4] = { 192, 0, 168, 66 }
public const status               /* initialized to zero */
|endverbatim\endlistingx

Three typical situations where one may use a constant variable are:
\beginlist{1em}\compactlist
\list{\lbullet}
  To create an ``array'' constant; symbolic constants cannot be indexed.
\list{\lbullet}
  \sidx{Host application}%
  For a public variable that should be set by the host application, and
  {\it only\/} by the host application. See the preceding section for public
  variables.
\list{\lbullet}
  A special case is to mark array arguments to functions as |const|. Array
  arguments are always passed by reference, declaring them as |const| guards
  against unintentional modification. Refer to \xref{p.ex.addvector} for an
  example of |const| function arguments.
\endlist


\subsection{Arrays (single dimension)}
\xrdef{p.data.arrays}
\noindent\marginbox0{See also ``multi-dimensional arrays'', page \xrefn{p.multdim-array}}%
The syntax |name[constant]| declares |name| to be an array of ``|constant|''
elements, where each element is a single cell. The |name| is a placeholder of
an identifier name of your choosing and |constant| is a positive non-zero
value; |constant| may be absent. If there is no value between the brackets, the
number of elements is set equal to the number of initiallers ---see the example
below.

The array index range is ``zero based'' which means that the first element is
at |name[0]| and the last element is |name[constant-1]|.


\subsection{Initialization}
\xrdef{p.data.initiallers}
Data objects can be initialized at their declaration.
\marginbox0{Constants: \xrefn{p.constants}}%
The initialler of a global data object must be a constant. Arrays, global or
local, must also be initialized with constants.

\sidx{Default initialization} \sidx{Data declarations}[default initialization]
Uninitialized data defaults to zero.

\goodbreak
Examples:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new i = 1
new j                             /* j is zero */
new k = 'a'                       /* k has character code for letter 'a' */

new a[] = {1,4,9,16,25}           /* a has 5 elements */
new s1[20] = {'a','b'}            /* the other 18 elements are 0 */

new s2[] = "Hello world..."       /* a unpacked string */
|endverbatim\endlistingx

\goodbreak
Examples of {\bf invalid} declarations:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new c[3] = 4                      /* an array cannot be set to a value */
new i = "Good-bye"                /* i must be an array for this initialler */
new q[]                           /* unknown size of array */
new p[2] = { i + j, k - 3 }       /* array initiallers must be constants */
|endverbatim\endlistingx


\subsection{Progressive initiallers for arrays}
\xrdef{p.progressive.init} \sidx{Progressive initiallers} \sidx{Arrays}[Progressive initiallers]
\sidx{Ellipsis operator}
The ellipsis operator continues the progression of the initialisation
constants for an array, based on the last two initialized elements. The
ellipsis operator (three dots, or ``|...|'') initializes the array up to its
declared size.

\goodbreak
Examples:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new a[10] = { 1, ... }            /* sets all ten elements to 1 */
new b[10] = { 1, 2, ... }         /* sets: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 */
new c[8] = { 1, 2, 40, 50, ... }  /* sets: 1, 2, 40, 50, 60, 70, 80, 90 */
new d[10] = { 10, 9, ... }        /* sets: 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 */
|endverbatim\endlistingx


\subsection{Multi-dimensional arrays}
%------------------------------------
\xrdef{p.multdim-array} \sidx{Arrays} \sidx{Data declarations}[arrays]
Multi-dimensional arrays are arrays that contain references to the
sub-arrays.\stdfootnote{The current implementation of the SMALL compiler
supports only arrays with up to two dimensions.\par} That is, a two-dimensional
array is an ``array of single-dimensional arrays''. Below are a few examples
of declarations of two-dimensional arrays.
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new a[4][3]
new b[3][2] = { { 1, 2 }, { 3, 4 }, { 5, 6 } }
new c[3][3] = { { 1 }, { 2, ...}, { 3, 4, ... } }
new d[2][5] = { !"agreement", !"dispute" }
new e[2][]  = { "OK", "Cancel" }
|endverbatim\endlistingx
\goodbreak

As the last declaration (variable ``|e|'') shows, the final dimension may have
an unspecified length, in which case the length of each sub-array is determined
from the related initializer. Every sub-array may have a different size; in
this particular example, ``|e[1][5]|'' contains the letter ''l'' from the word
``Cancel'', but ``|e[0][5]|'' is {\it invalid\/} because the length of the
sub-array ``|e[0]|'' is only three cells (containing the letters ``O'', ``K''
and a zero terminator).
\sidx[end]{Data declarations}


\subsection{Arrays and the sizeof operator}
%------------------------------------------
\xrdef{p.array-sizeof}
The |sizeof| operator returns the size of a variable in ``elements''. For a simple
(non-compound) variable, the result of sizeof is always 1, because an element is
a cell for a simple variable.

An array with one dimension holds a number of cells and the |sizeof| operator
returns that number. The snippet below would therefore print ``5'' at the
display, because the array ``|msg|'' holds four characters (each in one cell)
plus a zero-terminator:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new msg[] = "Help"
printf("%d", sizeof msg);
|endverbatim\endlistingx
\goodbreak

With multi-dimensional arrays, the |sizeof| operator can return the number of
elements in each dimension. For the last (minor) dimension, an element will
again be a cell, but for the major dimension(s), an element is a sub-array. In
the following code snippet, observe that the syntax |sizeof matrix| refers to
the major dimension of the two-dimensional array and the syntax |sizeof matrix[]|
refers to the minor dimension of the array. The values that this snippet prints
are 3 and 2 (for the major and minor dimensions respectively):
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new matrix[3][2] = { { 1, 2 }, { 3, 4 }, { 5, 6 } }
printf("%d %d", sizeof matrix, sizeof matrix[]);
|endverbatim\endlistingx
\goodbreak

\noindent\marginbox{-10}{Default function arguments and sizeof: \xrefn{p.default.args.sizeof}}%
The application of the |sizeof| operator on multi-dimensional arrays is
especially convenient when used as a default value for function arguments.


\subsection{Tag names}
%---------------------
\xrdef{p.tagnames} \sidx{Tag name}
A tag is a label that denotes the objective of ---or the meaning of--- a
variable, a constant or a function result. Tags are optional, their only
purpose is to allow a stronger compile-time error checking of operands in
expressions, of function arguments and of array indices.

\noindent\marginbox0{Label syntax: \xrefn{p.stmt.label}}%
A tag consists of a symbol name followed by a colon; it has the same
syntax as a label. A tag precedes the symbol name of a variable, constant
or function. In an assignment, only the right hand of the ``$=$'' sign may be
tagged.

Examples of valid tagged variable and constant definitions are:

\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new bool:flag = true        /* "flag" can only hold "true" or "false" */

const error:success = 0
const error:fatal= 1
const error:nonfatal = 2

error:errno = fatal
|endverbatim\endlistingx

\noindent\marginbox0{``enum'' statement: \xrefn{p.enum}}%
The sequence of the constants |success|, |fatal| and |nonfatal| could more
conveniently be declared using an |enum| instruction, as illustrated below. The
enumeration instruction below creates four constants, |success|, |fatal|,
|nonfatal| and |error|, all with the tag |error|.

\xrdef{p.ex.enum}
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
enum error {
    success,
    fatal,
    nonfatal,
}
|endverbatim\endlistingx

A typical use of ``tagged'' |enum|'s is in conjunction with arrays. If every
field of an array has a distinct purpose, you can use a tagged |enum| to
declare the size of an array and to add tag checking to the array usage
in a single step:

\xrdef{p.ex.rectangle}
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
enum rectangle
    {
    left,
    top,
    right,
    bottom
    }

new my_rect[rectangle]          /* array is declared as having 4 cells */

my_rect[left] = 10
my_rect[top] = 5
my_rect[right] = 30
my_rect[bottom] = 12

for (new i = 0; rectangle:i < rectangle; ++i)
    my_rect[rectangle:i] *= 2
|endverbatim\endlistingx

\sidx{Tag name}[override@\midtilde\ override] \sidx{Diagnostic}
After the declaration of ``|my_rect|'' above, you can access the second field
of |my_rect| with ``|my_rect[top]|'', but saying ``|my_rect[1]|'' will give a
parser diagnostic (a warning or error message). A tag override (or a
tag {\it cast}) adjusts a function, constant or variable to the desired
tag name. The |for| loop at the last two lines in the preceding example depicts
this: the loop variable |i| is a plain, untagged cell, an it must be cast to
the tag |rectangle| before as an index in the array |my_rect|. Note that
the |enum| construct has created both a constant and a tag with the name
``|rectangle|''.

\sidx{Tag name}[weak \midtilde] \sidx{Tag name}[strong \midtilde]
Tag names intruduced so far started with a lower case letter; these are ``weak''
tags. Tag names that start with an upper case letter are ``strong'' tags. The
difference between weak and strong tags is that weak tags may, in a few circumstances,
be dropped implicitly by the \Small\ parser ---so that a weakly tagged expression
becomes an untagged expression. The tag checking mechanism verifies the following
situations:
\beginlist{1em} \compactlist
\list{\lbullet}
  When the expressions on both sides of a binary operator have a different tag,
  or when one of the expressions is tagged and the other is not, the compiler
  issues a ``{\it tag mismatch\/}'' diagnostic. There is no difference between
  weak and strong tags in this situation.
\list{\lbullet}
  \sidx{Diagnostic} \sidx{lvalue}
  \marginbox0{``lvalue'': the variable on the left side in an assigment, see \xref{p.lvalue}}%
  There is a special case for the assignment operator: the compiler issues a
  diagnostic if the variable on the left side of an assignment operator has a tag, and
  the expression on the right side either has a different tag or is untagged.
  However, if the variable on the left of the assignment operator is untagged, it accepts
  an expression (on the right side) with a {\it weak\/} tag. In other words, a
  weak tag is dropped in an assignment when the {\it lvalue\/} is untagged.
\list{\lbullet}
  \sidx{Actual parameter} \sidx{Parameter}[actual \midtilde] \sidx{Formal parameter} \sidx{Parameter}[formal \midtilde]
  Passing arguments to functions follows the rule for assignments. The compiler
  issues a diagnostic when the {\it formal\/} parameter (in a function
  definition) has a tag and the {\it actual\/} parameter (in the function call)
  either is untagged or has a different tag. However, if the formal parameter
  is untagged, it also accepts a parameter with any {\it weak\/} tag.
\list{\lbullet}
  An array may specify a tag for every dimension, see the ``|my_rect|'' example
  above. Tag checking array indices follows the rule of binary operator tag
  checking: there is no difference between weak and strong tags.
\endlist

\vfill\eject
\footnotenumber=0%

\chapter{Functions}
%==================
\xrdef{p.functions}
\sidx[begin]{Functions} \sidx{Formal parameter} \sidx{Parameter}[formal \midtilde]
A function declaration specifies the name of the function and, between
parentheses, its formal parameters. A function may also return a value. A
function declaration must appear on a global level (i.e. outside any other
functions) and is globally accessible.

\sidx{Forward declaration} \sidx{Functions}[forward declaration]
\noindent\marginbox{-5}{The preferred way to declare forward functions is at \xref{p.function.forward}}%
If a semicolon follows the function declaration (rather than a statement),
the declaration denotes a forward declaration of the function.

The |return| statement sets the function result. For example, function |sum|
(see below) has as result the value of both its arguments added together. The
|return| expression is optional for a function, but one cannot use the value
of a function that does not return a value.
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
sum(a, b)
    return a + b
|endverbatim\endlistingx

Arguments of a function are (implicitly declared) local variables for that
function. The {\it function call\/} determines the values of the arguments.

Another example of a complete definition of the function |leapyear| (which
returns |true| for a leap year and |false| for a non-leap year): \sidx{Leap year} \codeidx{leapyear}
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
leapyear(y)
    return y % 4 == 0 && y % 100 != 0 |dvbar y % 400 == 0
|endverbatim\endlistingx

The logical and arithmetic operators used in the |leapyear| example are covered
on pages \xrefn{p.op.boolean} and \xrefn{p.op.arithmetic} respectively.

\noindent\marginbox0{``assert'' statement: \xrefn{p.stmt.assert}}%
Usually a function contains local variable declarations and consists of a
compound statement. In the following example, note the |assert| statement to
guard against negative values for the exponent.

\goodbreak
\codeidx{power}
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
power(x, y)
    {
    /* returns x raised to the power of y */
    assert y >= 0
    new r = 1
    for (new i = 0; i < y; i++)
        r *= x
    return r
    }
|endverbatim\endlistingx


\subsection{Function arguments (call-by-value versus call-by-reference)}
\xrdef{p.function.args}
\sidx{Call by value} \sidx{Functions}[call by value]

\sidx{Faculty}
The ``|faculty|'' function in the next program has one parameter which it uses
in a loop to calculate the faculty of that number. What deserves attention is that the function
modifies its argument.

\codeidx{faculty}
\bigskip\listfile{../examples/faculty.sma}
\verbatim|parskip=0pt|smalltt|Ccode|dofile|endverbatim\endlistingx

Whatever (positive) value that ``|n|'' had at the entry of the |while| loop
in function |faculty|, ``|n|''
will be zero at the end of the loop. In the case of the |faculty| function,
the parameter is passed ``by value'', so the change of ``|n|'' is local to the
|faculty| function. In other words, function |main| passes ``|v|'' as input
to function |faculty|, but upon return of |faculty|, ``|v|'' still has the
same value as before the function call.

Arguments that occupy a single cell can be passed by value or by reference.
The default is ``pass by value''. To create a function argument that is passed
by reference, prefix the argument name with the character |&|.
\sidx{Reference arguments} \sidx{Functions}[call by reference]

Example:
\codeidx{swap}
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
swap(&a, &b)
    {
    new temp = b
    b = a
    a = temp
    }
|endverbatim\endlistingx

To pass an array to a function, append a pair of brackets to the argument
name. You may optionally indicate the size of the array; doing so improves
error checking of the parser.

Example:
\xrdef{p.ex.addvector}
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
addvector(a[], const b[], size)
    {
    for (new i = 0; i < size; i++)
        a[i] += b[i]
    }
|endverbatim\endlistingx

\noindent\marginbox0{Constant variables: \xrefn{p.const.variable}}%
Arrays are always passed by reference. As a side note, array |b| in the above
example does not change in the body of the function. The function argument has
been declared as |const| to make this explicit. In addition to improving error
checking, it also allows the \Small\ parser to generate more efficient code.


\sidx{Ellipsis operator} \sidx{Literal array} \sidx[see]{Compound literals}{Literal array}
To pass an array of literals to a
function, use the same syntax as for array initiallers: a literal string or
the series of array indices enclosed in braces (see \xref{p.const.string};
the ellipsis for progressive initiallers cannot be used). Literal arrays can
only have a single dimension.

The following snippet calls |addvector| to add five to every element of the
array ``|vect|'':
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new vect[3] = { 1, 2, 3 }

addvector(vect, {5, 5, 5}, 3)

/* vect[] now holds the values 6, 7 and 8 */
|endverbatim\endlistingx

\noindent\marginbox0{``Hello world'' program: \xrefn{p.ex.hello}}%
The invocation of function |printf| with the string |"Hello world\n"| in the
first ubiquitous program is another example of passing a literal array to a
function.


\subsection{Named parameters versus positional parameters}
\xrdef{p.named.parameters}
\sidx{Named parameters} \sidx{Positional parameters}
In the previous examples, the order of parameters of a function call was
important, because each parameter is copied to the function argument with the
same sequential position. For example, with the function |weekday|
(which uses \nameidx{Zeller}Zeller's congruence algorithm) defined as below,
you call |weekday(12,31,1999)| to get the week day of the last day of this
century.

\goodbreak
\codeidx{weekday}
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
weekday(month, day, year)
    {
    /* returns the day of the week: 0=Saturday, 1=Sunday, etc. */
    if (month <= 2)
        month += 12, --year
    new j = year % 100
    new e = year / 100
    return (day + (month+1)*26/10 + j + j/4 + e/4 - 2*e) % 7
    }
|endverbatim\endlistingx

Date formats vary according to culture and nation. While the format
{\it month}\slash{\it day}\slash{\it year\/} is common in the United States of
America, European countries often use the
{\it day}\slash{\it month}\slash{\it year\/} format, and technical
publications sometimes standardize on the
{\it year}\slash{\it month}\slash{\it day\/} format. In other words, no order
of arguments in the |weekday| function is ``logical'' or ``conventional''.
That being the case, the alternative way to pass parameters to a function is
to use ``named parameters'', as in the next examples (the three function calls
are equivalent): \medskip
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
  new wkday1 = weekday( .month = 12, .day = 31, .year = 1999)

  new wkday2 = weekday( .day = 31, .month = 12, .year = 1999)

  new wkday3 = weekday( .year = 1999, .month = 12, .day = 31)
|endverbatim\endlistingx

With named parameters, a period (``.'') precedes the name of the function
argument. The function argument can be set to any expression that is valid
for the argument. The equal sign (``='') does in the case of a named
parameter not indicate an assignment; rather it links the expression that
follows the equal sign to one of the function arguments.

One may mix positional parameters and named parameters in a function call with
the restriction that all positional parameters must precede any named
parameters.


\subsection{Default values of function arguments}
%------------------------------------------------
\xrdef{p.default.args} \sidx{Functions}[default arguments]
\sidx{Default arguments} \sidx{Argument placeholder}
\sidx[see]{Placeholder}{Argument \midtilde}
\noindent\marginbox0{Public functions do not support default argument values; see \xref{p.public.funcs}}%
A function argument may have a default value. The default value for a function
argument must be a constant. To specify a default value, append the equal sign
(``|=|'') and the value to the argument name.

When the function call specifies an argument placeholder instead of a valid
argument, the default value applies. The argument placeholder is the
underscore character (|_|). The argument placeholder is only valid for
function arguments that have a default value.

If the rightmost argument placeholder may simply be stripped from the function
argument list. For example, if function |increment| is defined as:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
increment(&value, incr=1) value += incr
|endverbatim\endlistingx

the following function calls are all equivalent:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
increment(a)
increment(a, _)
increment(a, 1)
|endverbatim\endlistingx

Default argument values for passed-by-reference arguments are useful to make
the input argument optional. For example, if the function |divmod| is
designed to return both the quotient and the remainder of a division operation
through its arguments, default values make these arguments optional:

\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
divmod(a, b, &quotient=0, &remainder=0)
    {
    quotient = a / b
    remainder = a % b
    }
|endverbatim\endlistingx

With the preceding definition of function |divmod|, the following function
calls are now all valid:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new p, q

divmod(10, 3, p, q)
divmod(10, 3, p, _)
divmod(10, 3, _, q)
divmod(10, 3, p)
|endverbatim\endlistingx

Default arguments for array arguments are often convenient to set a default
string or prompt to a function that receives a string argument. For example:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
print_error(const message[], const title[] = "Error: ")
    {
    print(title)
    print(message)
    print("\n")
    }
|endverbatim\endlistingx

The next example adds the fields of one array to another array, and by default
increments the first three elements of the destination array by one:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
addvector(a[], const b[] = {1, 1, 1}, size = 3)
    {
    for (new i = 0; i < size; i++)
        a[i] += b[i]
    }
|endverbatim\endlistingx


\subsection{sizeof operator \& default function arguments}
%---------------------------------------------------------
\xrdef{p.default.args.sizeof}
\sidx{sizeof operator}[in function argument@\midtilde\ in function argument]
\noindent\marginbox0{sizeof operator \xrefn{p.op.sizeof}}%
A default value of a function argument must be a constant, and its value is
determined at the point of the function's {\it declaration}. Using the
``|sizeof|'' operator to set the default value of a function argument is a
special case: the calculation of the value of the |sizeof| expression is
delayed to the point of the function {\it call} and it takes the size of the
{\it actual\/} argument rather than that of the {\it formal\/} argument.
When the function is used several times in a program, with different arguments,
the outcome of the ``|sizeof|'' expression is potentially different at every
call ---which means that the ``default value'' of the function argument may
change.

\nameidx{Floyd, Robert} \sidx{Random sample}
Below is an example program that draws ten random numbers in the range of
0--51 without duplicates. An example for an application for drawing random
numbers without duplicates is in card games ---those ten numbers could represent
the cards for two ``hands'' in a poker game. The virtues of the algorithm used
in this program, invented by Robert W.\ Floyd, are that it is efficient and
unbiased ---provided that the pseudo-random number generator is unbiased as
well.\marginbox{180}{``random'' is a proposed core function, see page \xrefn{p.functions.proposed}}%

\xrdef{p.ex.randsamples}
\bigskip\listfile{../examples/randlist.sma}
\verbatim|parskip=0pt|smalltt|Ccode|dofile|endverbatim\endlistingx

\noindent\marginbox0{Array declarations: \xrefn{p.data.arrays}}%
Function |main| declares the array |HandOfCards| with a size of ten cells and
then calls function |FillRandom| with the purpose that it draws ten positive
random numbers below 52. Observe, however, that the only two parameters that
|main| passes into the call to |FillRandom| are the array |HandsOfCards|, where
the random numbers should be stored, and the upper bound ``52''. The number of
random numbers to draw (``10'') is passed {\it implicitly\/} to |FillRandom|.

\sidx{sizeof operator}[in function argument@\midtilde\ in function argument]
The definition of function |FillRandom| below main specifies for its third
parameter ``|Number = sizeof Series|'', where ``|Series|'' refers to the first
parameter of the function. Due to the special case of a ``|sizeof| default value'',
the default value of the |Number| argument is not the size of the formal
argument |Series|, but that of the actual argument at the point of the
function call: |HandOfCards|.

Note that inside function |FillRandom|, asking the ``|sizeof|'' the function
argument |Series| would (still) evaluate in zero, because the |Series| array is
declared with unspecified length (see \xref{p.op.sizeof} for the behaviour of
|sizeof|). Using |sizeof| as a default value for a function argument is a
specific case. If the formal parameter |Series| were declared with an explicit
size, as in |Series[10]|, it would be redundant to add a |Number| argument with
the array size of the actual argument, because the parser would then enforce
that both formal and actual arguments have the size and dimensions.


\subsection{Arguments with tag names}
%------------------------------------
\xrdef{p.tag.arguments}
A tag, see \xref{p.tagnames}, optionally precedes a function argument. Using
tags improves the compile-time error checking of the script and it serves
as ``implicit documentation'' of the function.  For example, a function that
computes the square root of an input value in fixed point precision may require
that the input parameter is a fixed point value and that the result is fixed
point as well. The function below uses the fixed point extension module, see
\xref{p.fixed.point}, and an approximation algorithm known as ``bisection'' to
calculate the square root. Note the use of tag overrides on numeric
literals.

\xrdef{p.ex.sqroot}
\sidx{Square root}\sidx{Fixed point arithmetic}\sidx{Bisection}
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
Fixed: sqroot(Fixed: value)
    {
    new Fixed: low = Fixed: 0
    new Fixed: high = value

    while (high - low > Fixed: 1)
        {
        new Fixed:mid = (low + high) / Fixed: 2
        if (fmul(mid, mid) < value)
            low = mid
        else
            high = mid
        }

    return low
    }
|endverbatim\endlistingx

\sidx{Newton-Raphson}
The bisection algorithm is related to binary search, in the sense that it
continuously halves the interval in which the result must lie. A ``successive
substitution'' algorithm like Newton-Raphson, that takes the slope of the
function's curve into account, achieves precise results more quickly, but
at the cost that a stopping criterion is more difficult to state. State of the
art algorithms for computing square roots combine bisection and Newton-Raphson
algorithms.

In the case of an array, the array indices can be tagged as well. For example,
a function that creates the intersection of two rectangles may be written as:
\noindent\marginbox0{For the ``rectangle'' tag, see \xref{p.ex.rectangle}}%
\listingx \def\pgrefa{\xref{p.functions.core}}%
\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
intersection(dest[rectangle], const first[rectangle], const second[rectangle])
    {
    if (first[right] > second[left] && first[left] < second[right]
        && first[bottom] > second[top] && first[top] < second[bottom])
        {
        /* there is an intersection, calculate it using the "min" and
         * "max" functions from the "core" library, see |pgrefa.
         */
        dest[left] = max(first[left], second[left])
        dest[right] = min(first[right], second[right])
        dest[top] = max(first[top], second[top])
        dest[bottom] = min(first[bottom], second[bottom])
        return true
        }
    else
        {
        /* "first" and "second" do not intersect */
        dest = { 0, 0, 0, 0 }
        return false
        }
    }
|endverbatim\endlistingx

%??? plurally tagged function arguments

%???
%\subsection{tagof operator \& default function arguments}
%--------------------------------------------------------
%\xrdef{p.default.args.tagof}
%\sidx{tag operator}[in function argument@\midtilde\ in function argument]
%\noindent\marginbox0{tagof operator \xrefn{p.op.tagof}}%


\subsection{Variable arguments}
%------------------------------
\xrdef{p.var.args}
\sidx{Variable arguments} \sidx{Functions}[variable arguments] \sidx{Ellipsis operator}
A function that takes a variable number of arguments, uses the ``ellipsis''
operator (``|...|'') in the function header to denote the position of the
first variable argument. The function can access the arguments with the
predefined functions |numargs|, |getarg| and |setarg| (see
\xref{p.functions.core}).

Function |sum| returns the summation of all of its parameters. It uses a
variable length parameter list.

\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
sum(...)
    {
    new result = 0
    for (new i = 0; i < numargs(); ++i)
        result += getarg(i)
    return result
    }
|endverbatim\endlistingx

This function could be used in:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new v = sum(1, 2, 3, 4, 5)
|endverbatim\endlistingx

\noindent\marginbox0{Tag names: \xrefn{p.tagnames}}%
A tag may precede the ellipsis to enforce that all subsequent parameters
have the same tag, but otherwise there is no error checking with a variable
argument list and this feature should therefore be used with caution.

\sidx{Reference arguments} \sidx{Call by reference}
The functions |getarg| and |setarg| assume that the argument is passed ``by reference''.
When using |getarg| on normal function parameters (instead of variable arguments)
one should be cautious of this, as neither the compiler nor the abstract machine
can check this. Actual parameters that are passed as part of ``avariable argument
list'' are always passed by reference.


\subsection{Coercion rules}
\sidx{Coercion rules} \sidx{Functions}[coercion rules]
\sidx[see]{Implicit conversions}{coercion rules}
If the function argument, as per the function definition (or its declaration), is a
``value parameter'', the caller can pass as a parameter to the function:
\beginlist{1em} \compactlist
\list{\lbullet} a value, which is passed by value;
\list{\lbullet} a reference, whose dereferenced value is passed;
\list{\lbullet} an (indexed) array element, which is a value.
\endlist \goodbreak

If the function argument is a reference, the caller can pass to the function:
\beginlist{1em} \compactlist
\list{\lbullet} a value, whose address is passed;
\list{\lbullet} a reference, which is passed by value because it has the type
  that the function expects;
%\list{\lbullet} an array, whose starting address is passed;
\list{\lbullet} an (indexed) array element, which is a value.
\endlist \goodbreak

If the function argument is an array, the caller can pass to the function:
\beginlist{1em} \compactlist
\list{\lbullet} an array with the same dimensions, whose starting address is
  passed;
\list{\lbullet} an (indexed) array element, in which case the address of the
  element is passed.
\endlist \goodbreak


\subsection{Recursion}
\sidx{Recursive functions}
\noindent\marginbox0{``faculty'': \xrefn{p.function.args}\lbreak
``fibonacci'': \xrefn{p.ex.fibonacci}}%
A |faculty| example function earlier in this chapter used a simple loop. An
example function that calculated a number from the Fibonacci series also used
a loop and an extra variable to do the trick. These two functions are the most
popular routines to illustrate recursive functions, so by implementing these
as iterative procedures, you might be inclined to think that \Small\ does not
support recursion.

Well, \Small\ {\it does\/} support recursion, but the calculation of faculties
and of Fibonacci numbers happen to be good examples of when
{\it not\/} to use recursion. Faculty is easier to understand with a loop than
it is with recursion. Solving Fibonacci numbers by recursion indeed simplifies
the problem, but at the cost of being extremely inefficient: the recursive
Fibonacci calculates the same values over and over again.

\noindent\marginbox0{There exists an intriguing iterative solution to the Towers of Hanoi.}%
The program below is an implementation of the famous ``Towers of Hanoi''
game in a recursive function:

\sidx{The Towers of Hanoi}\sidx{Hanoi, the Towers of \midtilde}
\listfile{../examples/hanoi.sma}
\verbatim|parskip=0pt|smalltt|Ccode|dofile|endverbatim\endlistingx


\subsection{Forward declarations}
\xrdef{p.function.forward}
\sidx{Forward declaration} \sidx{Functions}[forward declaration]
The current ``reference implementation'' of the \Small\ compiler does not require
functions to be declared before their first use. This section documents the
requirements of early implementations of the \Small\ compiler and of other
implementations of the \Small\ language (if they exist).

A \Small\ parser may require that functions are defined before they can be used.
That is, the implementation of the function must precede the first call to
that function in the source file. In the cases that this is inconvenient, or
impossible (as in the case of indirect recursion), you can make a ``forward
declaration'' of the function.
\marginbox0{Native function interface: \xrefn{p.native.funcs}}% and \xrefn{p.extension.modules}%
Forward declarations are similar, in syntax and in purpose, to declarations of
native functions.

To create a forward declaration, precede the function name and its parameter
list with the keyword |forward|. For compatibility with early versions of \Small,
and for similarity with C/\Cpp, an alternative way to forwardly declare a
function is by typing the function header and terminating it with a semicolon
(which follows the closing parenthesis of the parameter list).

The full definition of the function, with a non-empty body, is implemented
elsewhere in the source file.

\subsection{Public functions, function main}
%-------------------------------------------
\xrdef{p.public.funcs} \sidx{Public}[functions@\midtilde\ functions] \sidx{Functions}[public \midtilde]
A stand-alone program must have the function |main|. This function is the
starting point of the program. The function |main| may not have arguments.

A function library need not to have a |main| function, but it must have
{it either\/} a |main| function, {\it or\/} at least one public function.
Function |main| is the primary entry point into the compiled program; the
public functions are alternative entry points to the program. The virtual
machine can start execution with one of the public functions. A function
library may have a |main| function to perform one-time initialization at
startup.

To make a function public, prefix the function name with the keyword |public|.
For example, a text editor may call the public function ``|onkey|'' for every
key that the user typed in, so that the user can change (or reject) keystrokes.
The |onkey| function below would replace every ``|~|'' character (code 126
in the ISO Latin-1 character set) by the ``hard space'' code in the
ANSI character table:

\goodbreak
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
public onkey(keycode)
    {
    if (key=='~')
        return 160      /* replace ~ by hard space (code 160 in Latin-1) */
    else
        return key      /* leave other keys unaltered */
    }
|endverbatim\endlistingx

\sidx{\char64-symbol} %\char64 == @
Functions whose name starts with the ``@'' symbol are also public. So an
alternative way to write the public function |onkey| function is:

\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
@onkey(keycode)
    return key=='~' ? 160 : key
|endverbatim\endlistingx

The ``@'' character, when used, becomes part of the function name; that is,
in the last example, the function is called ``|@onkey|''.

\noindent\marginbox0{Default values of function arguments: \xrefn{p.default.args}}%
Arguments of a public function may not have default values. A public function
interfaces the host application to the \Small\ script. Hence, the arguments
passed to the public function originate from the host application, and the
host application cannot know what ``default values'' the script writter plugged
for function arguments ---which is why the \Small\ parser flags the use of
default values for arguments of public functions as an error. The issue of
default values in public function arguments only pops up in the case that you
wish to call public functions from the script itself.


\subsection{Static functions}
%----------------------------
\xrdef{p.static.funcs}
\sidx{Static}[functions@\midtilde\ functions] \sidx{Functions}[static \midtilde]
When the function name is prefixed with the keyword |static|, the scope of the
function is restricted to the file that the function resides in.


\subsection{Stock functions}
\xrdef{p.stock.funcs} \sidx{Stock}[functions@\midtilde\ functions] \sidx{Functions}[stock \midtilde]
A ``stock'' function is a function that the \Small\ parser must ``plug into''
the program when it is used, and that it may simply ``remove'' from the
program (without warning) when it is not used. Stock functions allow a
compiler or interpreter to optimize the memory footprint and the file size of
a (compiled) \Small\ program: any stock function that is not referred to, is
completely skipped ---as if it were lacking from the source file.

\sidx{Library functions}
A typical use of stock functions, hence, is in the creation of a set of
``library'' functions. A collection of general purpose functions, all marked
as ``stock'' may be put in a separate include file, which is then included in
any \Small\ script. Only the library functions that are actually used get
``linked'' in.

To declare a stock function, prefix the function name with the keyword |stock|.
Public functions and native functions cannot be declared ``stock''.

When a stock function calls other functions, it is usually a good practice
to declare those other functions as ``stock'' too ---with the exception of
native functions.
\marginbox0{Stock variables: \xrefn{p.stock.vars}}%
Similarly, any global variables that are used by a stock
function should in most cases also be defined ``stock''. The removal of
unused (stock) functions can cause a chain reaction in which other functions
and global variables are not longer accessed either. Those functions are then
removed as well, thereby continuing the chain reaction until only the functions
that are used, directly or indirectly, remain.


\subsection{Native functions}
%----------------------------
\xrdef{p.native.funcs}
\sidx{Native functions}\sidx{Functions}[native \midtilde]
A \Small\ program can call application-specific functions through a ``native
function''. The native function must be declared in the \Small\ program by
means of a function prototype. The function name must be preceded by the keyword
|native|.

Examples:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
native getparam(a[], b[], size)

native multiply_matrix(a[], b[], size)

native openfile(const name[])
|endverbatim\endlistingx

\sidx{Host application}%
The names ``|getparam|'', ``|multiply_matrix|'' and ``|openfile|'' are the
{\it internal\/} names of the native functions; these are the names by which
the functions are known in the \Small\ program. Optionally, you may also set an
{\it external\/} name for the native function, which is the name of the function
as the ``host application'' knows it. To do so, affix an equal sign to the
function prototype followed by the external name. For example:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
native getparam(a[], b[], size) = host_getparam

native multiply_matrix(a[], b[], size) = mtx_mul
|endverbatim\endlistingx

\sidx{Native functions}[external name] \sidx{External name}
Unless specified explicitly, the external name is equal to the internal name
of a native function. One typical use for explicit external names is to overcome
the maximum name length of a native function: the external name may not exceed
19 characters due to the specification of the executable file format. The
internal name may be longer, but only if the external ``alias'' is given
explicitly.

See the ``Implementor's Guide'' %\xref{p.extension.modules}
for implementing native functions in C/\Cpp\ (on the ``host application'' side).
\sidx[end]{Functions}


\subsection{User-defined operators}
%----------------------------------
\xrdef{p.user.opers}
\sidx{User-defined operators}\sidx{Operators}[user-defined \midtilde]
\noindent\marginbox0{Tags: \xrefn{p.tagnames}}%
The only data type of \Small\ is a ``cell'', typically a 32-bit number or
bit pattern. The meaning of a value in a cell depends on the particular
application ---it need not always be a signed integer value. \Small\ allows
to attach a ``meaning'' to a cell with its ``tag'' mechanism.

Based on tags, \Small\ also allows you to redefine operators for cells with
a specific purpose. The example below defines a tag ``|ones|'' and an operator
to add two ``ones'' values together (the example also implements operators for
subtraction and negation). The example was inspired by the checksum
algorithm of several protocols in the TCP/IP protocol suite: it simulates
one's complement arithmetic by adding the carry bit of an arithmetic overflow
back to the least significant bit of the value.

\goodbreak
\listfile{../examples/ones.sma}
\begingroup\catcode`\|=\other\verbatimescapechar!
\verbatim!parskip=0pt!smalltt!dofile!endverbatim\verbatimescapechar\|\endlistingx
\endgroup

The notable line in the example is the line ``|chksum = chksum + value|'' in
the loop in function |main|. Since both the variables |chksum| and |value|
have the tag |ones|, the |+| operator refers to the user-defined operator
(instead of the default |+| operator). User-defined operators are merely a
notational convenience. The same effect is achieved by calling functions
explicitly.

The definition of an operator is similar to the definition of a function,
with the difference that the name of the operator is composed by the
keyword ``|operator|'' and the character of the operator itself.
In the above example, both the unary |-| and the binary |-| operators are
redefined. An operator function for a binary operator must have two arguments,
one for an unary operator must have one argument. Note that the binary |-|
operator adds the two values together after inverting the sign of the second
operand. The subtraction operator thereby refers to both the user-defined
``negation'' (unary |-|) and addition operators.

A redefined operator must adhere to the following restrictions:
\beginlist{1em} \compactlist
\list{\lbullet}
  \noindent\marginbox{-5}{Forward declaration: \xrefn{p.function.forward}}%
  A user-defined operator must be declared before use (this is in contrast to
  ``normal'' functions): either put the implementation of the user-defined operator
  above the functions that use it, or add a forward declaration near the top of
  the file.
\list{\lbullet}
  Only the following operators may be redefined: |+|, |-|, |*|, |/|, |%|, |++|,
  |--|, |==|, |!=|, |<|, |>|, |<=|, |>=|, |!| and |=|. That is, the sets of
  arithmetic and relational operators can be overloaded, but the bitwise
  operators and the logical operators cannot. The |!| operator is a special case.
\list{\lbullet}
  You cannot invent new operators; you cannot define operator |#| for example.
\list{\lbullet}
  The precedence level and associativity of the operators, as well as their
  ``arity'' remain as defined. You cannot make an unary |+| operator, for
  example.
\list{\lbullet}
  The return tag of the relational operators and of the |!| operator must be
  |bool|.
\list{\lbullet}
  The return tag of the arithmetic operators is at your choosing, but you
  cannot redefine an operator that is identical to another operator except
  for its return tag. For example, you cannot make both \lbreak
  ~~~~~ |alpha: operator+(alpha: a, alpha: b)| \lbreak
  and \lbreak
  ~~~~~ |beta: operator+(alpha: a, alpha: b)|. \lbreak
  (The assignment operator is an exception to this rule.)
\list{\lbullet}
  \Small\ already defines operators to work on untagged cells, you cannot
  redefine the operators with only arguments without tags.
\list{\lbullet}
  The arguments of the operator function must be a non-array passed by value.
  You cannot make an operator work on arrays.
\endlist

In the example given above, both arguments of the binary operators have the
same tag. This is not required; you may, for example, define a binary $+$
operator that adds an integer value to a ``|ones|'' number.

Basically, the operation of the \Small\ parser is to look up the tag(s) of the
operand(s) that the operator works on and to look up whether a user-defined
operator exists for the combination of the operator and the tag(s). However,
the parser recognizes special situations and provides the following features:
\beginlist{1em} \compactlist
\list{\lbullet}
  The parser recognizes operators like |+=| as a sequence of |+| and |=| and
  it will call a user-defined operator |+| if available and\slash or a
  user-defined operator |=|. In the example program, the line
  ``|chksum = chksum + value|'' might have been abbreviated to
  ``|chksum += value|''.
\list{\lbullet}
  \sidx{Commutative operators} \sidx{Operators}[commutative \midtilde]
  The parser recognizes commutative operators (|+|, |*|, |==|, and |!=|)
  and it will swap the operands of a commutative operator if that produces
  a fit with a user-defined operator. For example, there is usually no need to
  implement both \lbreak
  ~\quad ``|ones:operator+(ones:a, b)|'' \lbreak
  and
  ~\quad ``|ones:operator+(a, ones:b)|''.
\list{\lbullet}
  Prefix and postfix operators are handled automatically. You only need to
  define one user operator for the |++| and |--| operators for a tag.
\list{\lbullet}
  The parser calls the |!| operator implictly in case of a test without
  explicit comparison. For example, in the statement ``|if (var) ...|'' when
  ``|var|'' has tag ``|ones|'', the user-defined operator |!| will be called
  for |var|. The |!| operator thus doubles as a ``test for zero'' operator.
  (In one's complement arithmetic, both the ``all-ones'' and the ``all-zeros''
  bit patterns represent zero.)
\list{\lbullet}
  \marginbox0{``Call by value'' versus ``call by reference'': \xrefn{p.function.args}}%
  The user-defined assigment operator is implicitly called for a function argument
  that is passed ``by value'' when the tag names of the {\it formal\/} and the
  {\it actual\/} arguments match the tag names of the left and right hand sides of
  the operator. In other words, the \Small\ parser similates that ``pass by value''
  happens through assignment. \sidx{Call by value} \sidx{Functions}[call by value]
  The user-defined operator is not called for function arguments that are passed
  ``by reference''.
\list{\lbullet}
  If you wish to forbid an operation, you can ``forward declare'' the operator
  without ever defining it (see \xref{p.function.forward}). This will flag an
  error when the user-defined operator is invoked. For example, to forbid the
  |%| operator (remainder after division) on floating point values, you can
  add the line: \lbreak
  ~~~~~ |forward float: operator%(float: a, float: b)|
\endlist

\noindent\marginbox0{Native functions: \xrefn{p.native.funcs}}%
User-defined operators can optionally be declared ``|stock|'' or ``|native|''.
In the case of a native operator function, the definition should include an
external name. \sidx{Native functions}[external name] \sidx{External name}
For example (when, on the host's side, the native function is called |float_add|):
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
native float: operator+(float: val, float: val) = float_add
|endverbatim\endlistingx

The user-defined assignment operator is a special case, because it is an operator
that has a side effect. Although the operator has the appearance of a binary
operator, its ``expression result'' is the value at the right hand ---the assignment
operator would be a ``null''-operator if it weren't for its side-effect. In
\Small\ a user-defined assignment operator is declared as:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
ones: operator=(a)
    return ones: ( (a >= 0) ? a : ~(-a) )
|endverbatim\endlistingx
The user-defined |=| operator looks like a unary operator in this definition, but
it is a special case nevertheless. In contrast to the other operators, the tag
of the return value for the user-defined operator is important: the \Small\ parser
uses the tags of the argument and the return value to find a matching user-defined
operator.

The example function above is a typical application for a user-defined assignment
operator: to automatically coerce\slash convert an untagged value to a tagged
value, and to optionally change the memory representation of the value in the
process. Specifically, the statement ``|new ones:A = -5|'' causes the user-defined
operator to run, and for the constant |-5| the operator will return ``|~(- -5 )|'',
or |~5|, or $-6$.\stdfootnote{Modern CPUs use two's complement integer arithmetic.
For positive values, the bitwise representation of a value is the same in one's
complement and two's complement, but the representations differ for negative values.
For instance, the same bit pattern that means $-5$ in one's complement stands for
$-6$ in two's complement.\par}


\subsection{Floating point and fixed point arithmetic}
%-----------------------------------------------------
\xrdef{p.floating.point} \sidx{Floating point arithmetic}\sidx{Fixed point arithmetic}
\Small\ only has intrinsic support for integer arithmetic (integer numbers are
numbers without a fractional part). Support for floating point arithmetic or
fixed point arithmetic must be implemented through (native) functions. User
operators, then, allow a more natural notation of expressions with fixed or
floating point numbers.

\noindent\marginbox0{Rational literals: \xrefn{p.rational}\lbreak \#pragma rational: \xrefn{p.rational.p}}%
The \Small\ parser has support for literal values with a fractional part, which
it calls ``rational numbers''. Support for rational literals must be enabled
explicitly with a |#pragma|. The |#pragma| indicates how the rational numbers
must be stored ---floating point or fixed point. For fixed point rational
values, the |#pragma| alse specifies the precision in decimals. Two examples
for the |#pragma| are:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
#pragma rational float      /* floating point format */

#pragma rational fixed(3)   /* fixed point, with 3 decimals */
|endverbatim\endlistingx

Since a fixed point value must still fit in a cell, the number of decimals
has a direct influence of the range of a fixed point value. For a fixed point
value with 3 decimals, the range would be $-2,147,482 \dots\ +2,147,482$.

The format for a rational number may only be specified once for the entire
\Small\ program. In an implementation one typically chooses either floating
point support or fixed point support. As stated above, for the actual
implementation of the floating point or fixed point arithmetic, \Small\ requires
the help of (native) functions and user-defined operators. A good place to
put the |#pragma| for rational number support would be in the include file
that also defines the functions and operators.

The include file for fixed point arithmetic contains definitions like:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
native Fixed: operator*(Fixed: val1, Fixed: val2) = fmul
native Fixed: operator/(Fixed: val1, Fixed: val2) = fdiv
|endverbatim\endlistingx

The user-defined operators for multiplication and division of two fixed point
numbers are aliased directly to the native functions |fmul| and |fdiv|. The
host application must, then, provide these native functions.

Another native user-defined operator is convenient to transform an integer to
fixed point automatically, if it is assigned to a variable tagged as ``|Fixed:|'':
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
native Fixed:operator=(oper) = fixed
|endverbatim\endlistingx

\noindent\marginbox0{User-defined operators: \xrefn{p.user.opers}}%
With this definition, you can say ``|new Fixed: fract = 3|'' and the value
will be transformed to |3.000| when it is stored in variable |fract|. As explained
in the section on user-defined operators, the assignment operator also runs for
function arguments that are passed by value. In the expression
``|new Fixed: root = sqroot(16)|'' (see the implementation of function |sqroot|
on \xref{p.ex.sqroot}), the user-defined assignment operator is called on the
argument |16|.

For adding two fixed point values together, the default |+| operator is
sufficient, and the same goes for subtraction. Adding a normal (integer)
number to a fixed point number is different: the normal value must be
scaled before adding it. Hence, the include file implements operators for
that purpose too:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
stock Fixed: operator+(Fixed: val1, val2)
    return val1 + fixed(val2)

stock Fixed: operator-(Fixed: val1, val2)
    return val1 - fixed(val2)

stock Fixed: operator+(val1, Fixed: val2)
    return fixed(val1) - val2
|endverbatim\endlistingx

The |+| operator is commutative, so one implementation handles both cases. For
the |-| operator, both cases must be implemented separately.

Finally, the include file forbids the use of the modulus operator (|%|) on
fixed point values: the modulus is only applicable to integer values:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
forward Fixed: operator%(Fixed: val1, Fixed: val2)
forward Fixed: operator%(Fixed: val1, val2)
forward Fixed: operator%(val1, Fixed: val2)
|endverbatim\endlistingx

By declaring the operator, the \Small\ parser will attempt to use the user-defined
operator rather than the default |%| operator. By not implementing the operator,
the parser will subsequently issue an error message.


\vfill\eject
\footnotenumber=0%

\chapter{The preprocessor}
%=========================
\xrdef{p.preprocessor}
\sidx[begin]{Preprocessor}
\sidx{P-code}
The first phase of compiling a \Small\ source file to the executable P-code is
``preprocessing'': a general purpose text filter that modifies\slash cleans up
the text before it is fed into the parser. The preprocessing phase removes
comments, strips out ``conditionally compiled'' blocks, processes the compiler
directives and performs find-\&-replace operations on the text of the source
file. The compiler directives are summarized on \xref{p.directives} and the
text substitution (``find-\&-replace'') is the topic of this chapter.

\sidx{Text substitution}
The preprocessor is a process that is invoked on all source
lines immediately after they are read. No syntax checking is performed during
the text substitutions. While the preprocessor allows powerfull tricks in the
\Small\ language, it is also easy to shoot yourself in the foot with it.

In this chapter, I will refer to the C/\Cpp\ language on several occasions
because \Small's preprocessor is similar to the one in C/\Cpp. That said, the
\Small\ preprocessor is incompatible with the C/\Cpp\ preprocessor.

\sidx{Preprocessor}[macro@\midtilde\ macro] \sidx{Macro} \codeidx{\#define}
The |#define| directive defines the preprocessor macros. Simple macros are:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
#define maxsprites       25
#define CopyRightString  "(c) Copyright 2003 by me"
|endverbatim\endlistingx
In the \Small\ script, you can then use them as you would use constants. For
example:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
#define maxsprites  25
#define CopyRightString "(c) Copyright 2003 by me"
main()
    {
    print( Copyright )
    new sprites[maxsprites]
    }
|endverbatim\endlistingx
\xrdef{p.string.constant}
By the way, for these simple macros there are equivalent \Small\ constructs:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
const maxsprites = 25
stock const CopyRightString[] = "(c) Copyright 2003 by me"
|endverbatim\endlistingx
These constant declarations have the advantage of better error checking and the
ability to create tagged constants. The syntax for a string constant is an array
variable that is declared both ``|const|'' and ``|stock|''. The |const| attribute
prohibits any change to the string and the |stock| attribute makes the declaration
``disappear'' if it is never referred to.

Substitution macros can take up to 10 parameters. A typical use for
parametrized macros is to simulate tiny functions:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
#define min(%1,%2)      ((%1) < (%2) ? (%1) : (%2))
|endverbatim\endlistingx
If you know C/\Cpp, you will recognize the habit of enclosing each argument
and the whole substitution expression in parantheses.

If you use the above macro in a script in the following way:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new a = 1, b = 4
new min = min(++a,b)
|endverbatim\endlistingx
the preprocessor translates it to:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new a = 1, b = 4
new min = ((++a) < (b) ? (++a) : (b))
|endverbatim\endlistingx
which causes ``|a|'' to possibly be incremented twice. This is one of the traps
that you can trip into when using substitution macros (this particular
problem is well known to C/\Cpp\ programmers). Therefore, it may be a good idea
to use a naming convention to distinguish macros from functions. In C/\Cpp\
it is common practice to write preprocessor macros in all upper case.

To show why enclosing macro arguments in parentheses is a good idea, consider
the macro:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
#define ceil_div(%1,%2) (%1 + %2 - 1) / %2
|endverbatim\endlistingx
This macro divides the first argument by the second argument, but rounding {\it upwards\/}
to the nearest integer (the divide operator, ``|/|'', rounds downwards). If you
use it as follows:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new a = 5
new b = ceil_div(8, a - 2)
|endverbatim\endlistingx
\vskip-\parskip
\noindent\marginbox0{Operator precedence: \xrefn{p.op.precedence}}
the second line expands to ``|new b = (8 + a - 2 - 1) / a - 2|'', which, considering
the precedence levels of the \Small\ operators, leads to |b| being set to zero (if |a|
is 5). What you would have expected from looking at the macro invokation is eight
divided by three (|a - 2|), rounded upwards ---hence, that |b| would be set to
the value 3. Changing the macro to enclose each parameter in parentheses solves
the problem. For similar reasons, it is also advised to enclose the complete
replacement text in parentheses. Below is the |ceil_div| macro modified accordingly:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
#define ceil_div(%1,%2) ( ((%1) + (%2) - 1) / (%2) )
|endverbatim\endlistingx

The pattern matching is subtler than matching strings that look like function
calls. The pattern matches text literally, but accepts arbitrary text where
the pattern specifies a parameter. You can create patterns like:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
#define Object[%1]      CallObject(%1)
|endverbatim\endlistingx
\vskip-\parskip
which translates a syntax for array access to a function call.

When the expansion of a macro contains text that matches other macros, the
expansion is performed at invocation time, not at definition time. Thus the
code:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
#define a(%1)      (1+b(%1))
#define b(%1)      (2*(%1))
new c = a(8)
|endverbatim\endlistingx
\vskip-\parskip
will evaluate to ``|new c = (1+(2*(8)))|'', even though the macro |b| was not
defined at the time of the definition of |a|.

The pattern matching is constrained to the following rules:
\beginlist{1em}\compactlist
\list{\lbullet}
  There may be {\it no space characters\/} in the pattern. If you must match a space,
  you need to use the ``|\32;|'' escape sequence.
\list{\lbullet}
  As evidenced in the preceding line, escape sequences may appear in the
  pattern (they are not very useful, though).
\list{\lbullet}
  The pattern may not end with a parameter; a pattern like ``|set %1=%2|'' is
  illegal. If you wish to match with the end of a statement, you can add a
  semicolon at the end of the pattern. If semicolons are optional at the end of
  each statement, the semicolon will also match a newline in the source.
\list{\lbullet}
  \sidx{Macro}[prefix@\midtilde\ prefix] \codeidx{\#undef}
  The pattern must start with a letter, an underscore or an ``|@|'' character.
  The first part of the pattern that consists of alphanumeric characters (plus
  ``|_|'' and ``|@|'') is the ``name'' or the ``prefix'' of the macro. On the
  |defined| operator and the |#undef| directive, you specify the macro prefix.
\list{\lbullet}
  When matching a pattern, the preprocessor ignores white space between
  non-alphanumeric symbols, with one exception, or between an alphanumeric
  symbol and a non-alphanumeric one. The exception is that between two
  identical symbols, white space is not ignored. Therefore:
  \beginlist{1em}\compactlist
  \list{~}
        the pattern |abc(+-)| matches ``|abc ( + - )|''
  \list{~}
        the pattern |abc(--)| matches ``|abc ( -- )|'' but does not match ``|abc(- -)|''
  \endlist
\list{\lbullet}
  There are up to 10 parameters, denoted with a ``|%|'' and a single digit (1 to
  9 and 0). The order of the parameters in a pattern is not important.
\list{\lbullet}
  \noindent\marginbox0{Directives: \xrefn{p.directives}}
  \sidx{Directives} \codeidx{\#define}
  The |#define| symbol is a parser {\it directive\/}. As with all parser
  directives, the pattern definition must fit on a single line. You can
  circumvent this with a ``|\|'' on the end of the line.
  The text to match must also fit on a single line.
\endlist

Note that in the presence of (parametrized) macros, lines of source code may
not be what they appear: what looks like an array access may be ``preprocessed''
to a function call, and vice versa.

A host application that embeds the \Small\ parser may provide an option to
let you check the result of text substitution through macros.
If you are using the standard \Small\ toolset, you will find instructions of how
to use the compiler and run-time in the companion booklet ``The \Small\ booklet
--- Implementor's Guide''.
\sidx[end]{Preprocessor}


\vfill\eject
\footnotenumber=0%

\chapter{General syntax}
%=======================
\xrdef{p.general.syntax} \sidx{Syntax rules}

\beginlist{35pt} \halflineskip
\item Format:
        Identifiers, numbers and tokens are separated by spaces, tabs,
        carriage returns and ``form feeds''. Series of one or more of these
        separators are called white space. \sidx{White space}

\item Optional semicolons: \sidx{Optional semicolons}\sidx{Semicolons, optional} \xrdef{p.opt.semicolon}
        \noindent\marginbox0{Optional semicolons: \xrefn{p.semicolon.p}} %\xrefn{p.compiler.options}}
        Semicolons (to end a statement) are optional if they occur at the end
        of a line. Semicolons are required to separate multiple statements on
        a single line. An expression may still wrap over multiple lines, however
        postfix operators (|++|, |--| and |char|) {\it must\/} appear on the
        same line as their operand.

\item Comments: \sidx{Comments} \sidx{Single line comment} \xrdef{p.comment}
        Text between the tokens |/*| and |*/| (both tokens may be at the same
        line or at different lines) and text behind |//| (up to the end of the
        line) is a programming comment. The parser treats a comment as white
        space. Comments may not be nested.

\item Identifiers: \xrdef{p.syntax.identifiers} \sidx{Identifiers}
        Names of variables, functions and constants. Identifiers consist of the
        characters |a|\dots |z|, |A|\dots |Z|, |0|\dots |9|, |_| or |@|; the
        first character may not be a digit. The characters |@| and |_| by
        themselves are not valid identifiers, i.e. ``|_Up|'' is a valid
        identifier, but ``|_|'' is not.

        \Small\ is case sensitive.

        A parser may truncate an identifier after a maximum length. The
        number of significant characters is implementation defined, but should
        be at least 16 characters.

\itemnb Reserved words (keywords): \sidx{Reserved words} \sidx[see]{Keywords}{reserved words}
        \settabs\+\hfill to 35pt & Statements \quad & Operators \quad & Directives \quad & Other &\cr
                \+&Statements \quad & Operators \quad & Directives \quad & Other &\cr
                \vskip -6pt
                \+& \vrule width 2.8in height 0.4pt \cr
                \+&assert    & char     & \#assert   & const   &\cr
                \+&break     & defined  & \#define   & enum    &\cr
                \+&case      & sizeof   & \#else     & forward &\cr
                \+&continue  & tagof    & \#emit     & native  &\cr
                \+&default   &          & \#endif    & new     &\cr
                \+&do        &          & \#endinput & operator&\cr
                \+&else      &          & \#endscript& public  &\cr
                \+&exit      &          & \#file     & static  &\cr
                \+&for       &          & \#if       & stock   &\cr
                \+&goto      &          & \#include  &         &\cr
                \+&if        &          & \#line     &         &\cr
                \+&return    &          & \#undef    &         &\cr
                \+&sleep     &          &            &         &\cr
                \+&switch    &          &            &         &\cr
                \+&while     &          &            &         &\cr

        \noindent\marginbox0{Predefined constants: \xrefn{p.predefined.constants}}%
        Next to reserved words, \Small\ also has several predefined
        constants, you cannot use the symbol names of the predefined constants
        for variable or function names.

\itemnb Constants (literals): \xrdef{p.constants} \sidx{Constants}[literals] \sidx[see]{Literals}{Constants}
    \eatvskip
    \beginlist{35pt}
    \itemnb Integer numeric constants:
        \beginlist{35pt} \compactlist
        \item binary:      \sidx{Binary radix} |0b| followed by a series of the
                           digits 0 and 1.

        \item decimal:     a series of digits between 0 and 9.

        \item hexadecimal: \sidx{Hexadecimal radix}|0x| followed by a series of
                           digits between 0 and 9 and the letters |a| to |f|.
        \endlist
        In all number radices, an underscore may be used to separate groups of
        (hexa-)decimal digits. Underscore characters between the digits are
        ignored.

    \item Rational number constants: \xrdef{p.rational}
        \sidx{Rational numbers} \sidx{Floating point arithmetic}
        \noindent\marginbox0{Rational numbers are also called ``real numbers'' or ``floating point numbers''}%
        A rational number is a number with a fractional part. A rational number
        starts with one or more digits, contains a decimal point and has at
        least one digit following the decimal point. For example, ``12.0'' and
        ``0.75'' are valid rational numbers. Optionally, an exponent may be
        appended to the rational number; the exponent notation is the letter
        |e| (lower case) followed by a signed integer numeric constant. For
        example, ``3.12e4'' is a valid rational number with an exponent.

        \noindent\marginbox0{\#pragma rational: \xrefn{p.rational.p}}%
        Support for rational numbers must be enabled with |#pragma rational|
        directive. Depending on the options set with this directive, the
        rational number represents a floating point or a fixed point number.

    \item Character constants: \xrdef{p.character.constants}
        A single ASCII character surrounded by single quotes is a character
        constant (for example: |'a'|, |'7'|, |'$'|). Character constants are
        assumed to be numeric constants.

        Escape sequences \sidx{Escape sequences}% \char94=^
        \settabs\+ \hbox to 70pt{\hss.\hss}& \tt '\BS{\it ddd};' \quad & \tt * \quad & character code with {\it decimal\/} code ``ddd'' &\cr
                \vskip -6pt
                \+ & \vrule width 2.8in height 0.4pt \cr
                \+ & \tt '\BS a'        &       & Audible alarm (beep) \cr
                \+ & \tt '\BS b'        &       & Backspace            \cr
                \+ & \tt '\BS e'        &       & Escape               \cr
                \+ & \tt '\BS f'        &       & Formfeed             \cr
                \+ & \tt '\BS n'        &       & Newline              \cr
                \+ & \tt '\BS r'        &       & Carriage Return      \cr
                \+ & \tt '\BS t'        &       & Horizontal tab       \cr
                \+ & \tt '\BS v'        &       & Vertical tab         \cr
                \+ & \tt '\BS\BS'       & \BS   & the escape character \cr
                \+ & \tt '\BS{'}'       & \tt ' & single quote         \cr
                \+ & \tt '\BS "'        & \tt " & double quote         \cr
                \+ & \tt '\BS{\it ddd};'&       & character code with {\it decimal\/} code ``{\it ddd\/}'' \cr

        The semicolon after the {\tt \BS {\it ddd};} code is optional. Its
        purpose is to give the escape sequence sequence an explicit termination
        symbol when it is used in a string constant.

        \xrdef{p.def.ctrlchar}
        The backslash (``|\|'') is the default ``escape'' character. You can set
        a different escape character with the |#pragma ctrlchar| directive
        (\xref{p.ctrlchar}).

    \item String constants: \xrdef{p.const.string}
        String constants are assumed to be arrays with a size that is sufficient
        to hold all characters plus a terminating 0. Each string is stored at a
        unique position in memory; there is no elimination of duplicate strings.

        \sidx{Unpacked string} \sidx{String}[unpacked \midtilde]
        An {\it unpacked\/} string is a series of zero or more ASCII characters
        surrounded by double quotes. Each array element contains a single
        character.

        {\bf unpacked string constant:} \lbreak
        \tabto 20pt |"the quick brown fox..."|

        \sidx{Packed string} \sidx{String}[packed \midtilde]
        A {\it packed\/} string literal follows the syntax for an unpacked
        string, but a ``|!|'' precedes the first double quote.

        {\bf packed string constant:} \lbreak
        \tabto 20pt |!"...packed and sacked the lazy dog"|

        The syntax for packed literal strings and unpacked literal strings can
        be swapped with the |#pragma pack| directive, see \xref{p.pack.p}.

        \sidx{Big Endian}
        In the case of a packed string, the parser packs as many characters
        in a cell as will fit. A character is not addressable as a single
        unit, instead each element of the array contains multiple characters.
        The first character in a ``pack'' occupies the highest bits of the
        array element. In environments that store memory words with the high
        byte at the lower address (Big Endian, or Motorola format), the
        individual characters are stored in the memory cells in the same order
        as they are in the string. A packed string ends with a zero character
        and the string is padded (with zero bytes) to a multiple of cells.

        \sidx{Escape sequences}
        Escape sequences may be used within strings. See the section on
        character constants above for a list of escape sequences.

        \sidx{Plain strings} \sidx{String}[plain \midtilde]
        There is an alternative syntax for ``plain strings''. In a plain string,
        every character is taken as-is and escape sequences are not recognized.
        Plain strings are convenient to store file\slash resource names, especially
        in the case where the escape character is also used as a special character
        by the operating system or host application.

        The syntax for a plain string is the escape character followed by the
        string in double quotes. The backslash (``|\|'') is the default
        ``escape'' character. You cannot enter escape sequences in a plain string:
        all characters will be taken literally.

        {\bf plain string constant:} \lbreak
        \tabto 20pt |\"C:\all my work\novel.rtf"|

        In the above example, the occurrences of ``|\a|'' and ``|\n|'' do {\it not\/}
        indicate escape sequences, but rather the literal character pairs ``|\|'' and
        ``|a|'', and ``|\|'' and ``|n|''.

        A packed plain string has both the ``!'' and the escape character prefixing
        the opening double quote. Both strings below are packed plain strings: \lbreak
        \tabto 20pt |!\"C:\all my work\novel.rtf"| \lbreak
        \tabto 20pt |\!"C:\all my work\novel.rtf"|

    \item Array constants: \xrdef{p.const.array}
        A series of numeric constants between braces is an array constant.
        Array constants can be used to initialize array variables with (see
        \xref{p.data.initiallers}) and they can be passed as function
        arguments (see \xref{p.function.args}).

    \endlist

\item Symbolic constants:
    \sidx{Symbolic constants} \sidx{Constants}[symbolic \midtilde]
    A source file declares symbolic constants with the |const|
    and the |enum| instructions.
    The |const| keyword declares a single constant and the |enum| defines a
    list of ---usually--- sequential constants sharing the same tag name.

    \beginlist{35pt}
    \item const {\it identifier\/} = {\it constant expression\/}:
    \xrdef{p.const}
            Creates a symbolic constant with the value of the constant
            expression on the right hand of the assignment operator. The
            constant can be used at any place where a literal number is valid
            (for example: in expressions, in array declarations and in
            directives like ``|#if|'' and ``|#assert|'').

    \item enum {\it name\/} ({\it increment}) $\{$ {\it constant list\/} $\}$:
    \xrdef{p.enum} \codeidx{enum}
            The |enum| instruction creates a series of constants with
            incrementing values. \marginbox0{Identifiers: \xrefn{p.syntax.identifiers}}%
            The {\it constant list\/} is a series of identifiers separated by
            commas. Unless overruled, the first constant of an |enum| list has
            the value 0 and every subsequent constant has the value of its
            predecessor plus 1.

            Both the value of a constant and the increment value can be set
            by appending the value to the constant's identifier.
            To set a value, use %\lbreak
            \tabto 35pt {\it name}| = |{\it value} \lbreak
            in the constant list. To set the increment, use:
            \tabto 35pt {\it name}| : |{\it increment} \lbreak
            The increment value is reset to 1 after every constant symbol
            declaration in the constant list.

            If both an increment and a value should be set for a constant, the
            increment (``|:|'' notation) should precede the value (``|=|''
            notation.

            The symbols in the constant list may not be tagged.

            \sidx{Tag name}[and enum@\midtilde\ and enum]
            The {\it name\/} token that follows the |enum| keyword is optional.
            If it is included, this name is used as the tag name for every
            symbol in the constant list.
            \marginbox0{See page \xrefn{p.ex.enum} for examples of the ``enum''
            constant declarations}%
            In addition, the |enum| command creates an extra constant with
            {\it name\/} for the constant name and the tag name. The value of the
            last constant is the value of the last symbol in the constant list
            plus the increment value of that last constant.

            \noindent\marginbox0{See page \xrefn{p.ex.set} for an example of a
            custom increment rule}%
            The {\it increment\/} token that follows the optional {\it name\/}
            token is also optional. If included, it specifies a different
            post-increment rule. By default, an |enum| increments the value of
            every succesive constant with 1, but you may specify a different
            rule with the syntax ``({\it operator\/} {\it constant})'', where
            {\it operator\/} must be |+=|, |*=| or |<<=|. The |+=| operator
            creates an additive increment, the |*=| and |<<=| create a
            multiplicative increment. The {\it constant\/} may be a literal
            value or a symbolic constant. The increment rule {\it must\/} be
            enclosed in parentheses. If no increment rule is specified, the
            parenthese may be omitted as well.

    \endlist

    A symbolic constant that is defined locally, is valid throughout the
    block. A local symbolic constant may not have the same name as a
    variable (local or global), a function, or another constant (local or
    global).

\item Predefined constants: \xrdef{p.predefined.constants}
        \sidx{Constants}[predefined \midtilde]
        \eatvskip
        \beginlist{50pt}\compactlist
        \list{\tt false}    0 (this constant is tagged as |bool:|)
        \list{\tt true}     1 (this constant is tagged as |bool:|)
        \list{\tt cellbits} The size of a cell in bits; usually 32.
        \list{\tt cellmax}  The largest valid positive value that a cell can
                            hold; usually 2147483647.
        \list{\tt cellmin}  The largest valid negative value that a cell can
                            hold; usually -2147483648.
        \list{\tt charbits} The size of a character in bits; 8 when using the
                            ASCII or ISO Latin-1 characters sets and 16 when
                            using the Unicode character set.
                            \sidx{Unicode} \sidx{ASCII} \sidx{ISO Latin-1}
                            \sidx[see]{Latin-1 (character set)}{ISO Latin-1}
        \list{\tt charmax}  The largest valid character value; 255 for 8-bit
                            characters and 65535 for 16-bit characters.
        \list{\tt charmin}  The smallest valid character value, currently set
                            at zero (0).
        \list{\tt debug}    \sidx{Assertions} \sidx{Debug level}
                            The debug level: 2 if the parser creates full symbolic
                            information plus run-time bounds checking, 1 if the
                            parser generates run-time checking only (assertions
                            and array bounds checks), and 0 (zero) if all debug
                            support and run-time checking was turned off.
        \list{\tt __Small}  The version number of the \Small\ compiler scaled by
                            100 (that is, for version 1.7 the constant is
                            ``170'').
        \endlist

\item Tag names: \xrdef{p.syntax.tagnames}
        \noindent\marginbox0{Identifiers: \xrefn{p.syntax.identifiers}}%
        A tag consists of an identifier followed by a colon. There may be
        no white space between the identifier and the colon. \sidx{Tag name}[syntax@\midtilde\ syntax]

\item Predefined tag names: \xrdef{p.predefined.tagnames}
        \sidx{Tag name}[predefined \midtilde]
        \eatvskip
        \beginlist{50pt}\compactlist
        \list{\tt bool}
            For ``true/false'' flags. The predefined constants |true| and
            |false| have this tag.
        \list{\tt Fixed}
            Rational numbers typically have this tag when fixed point
            support is enabled (\xref{p.rational.p}).
        \list{\tt Float}
            Rational numbers typically have this tag when floating point
            support is enabled (\xref{p.rational.p}).
        \endlist
\endlist

\vfill\eject %???
\chapter{Operators and expressions}
\xrdef{p.operators} \sidx[begin]{Operators}

\vskip -12pt\relax
\subsection{Notational conventions}
The operation of some operators depends on the specific kinds of operands.
Therefore, operands are notated thus:
\beginlist{35pt} \compactlist
\list{~~\bf e} any expression;
\list{~~\bf v} any expression to which a value can be assigned (``lvalue'' expressions);
               \sidx{lvalue} \xrdef{p.lvalue}
\list{~~\bf a} an array;
\list{~~\bf f} a function;
\list{~~\bf s} a symbol ---which is a variable, a constant or a function.
\endlist


\subsection{Expressions}
An expression consists of one or more operands with an operator. The operand
can be a variable, a constant or another expression. An expression followed by
a semicolon is a statement.

Examples of expressions:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
v++
f(a1, a2)
v = (ia1 * ia2) / ia3
|endverbatim\endlistingx

% Define colums (tabs) for the subesquent sections
\settabs\+ \hbox to 35pt{\hss.\hss}& \hbox to 35pt{\hss.\hss}& \cr
%\def\tabrule{\tabalign&\vrule width 5in height 0.4pt \cr}

\subsection{Arithmetic}
\xrdef{p.op.arithmetic}

    \+& \tt + & \tt e1 + e2 \cr
    \+&       & Results in the addition of e1 and e2. \cr
    \bigskip

    \+& \tt - & \tt e1 - e2 \cr
    \+&       & Results in the subtraction of e1 and e2. \cr
    \medskip \goodbreak
    \+&       & \tt -e \cr
    \+&       & Results in the arithmetic negation of a (two's complement). \cr
    \bigskip \goodbreak

    \+& \tt * & \tt e1 * e2 \cr
    \+&       & Results in the multiplication of e1 and e2. \cr
    \bigskip \goodbreak

    \+& \tt / & \tt e1 / e2 \cr
    \+&       & \vtop{\hsize=4.0in\noindent Results in the division of e1
                by e2. The result is truncated to the nearest integral value
                that is less than or equal to the quotient. Both negative and
                positive values are rounded towards $-\infty$.} \cr
    \bigskip \goodbreak

    \+& \tt \% & \tt e1 \% e2 \cr
    \+&       & \vtop{\hsize=4.0in\noindent Results in the modulus (remainder
                of the division) of e1 by e2. The modulus is always a
                positive value.} \cr
    \bigskip

    \+& \tt ++& \tt v++ \cr
    \+&       & \vtop{\hsize=4.0in\noindent increments v by 1; results in the
                value of v before it is incremented.} \cr

    \+& \tt   & \tt ++v \cr
    \+&       & \vtop{\hsize=4.0in\noindent increments v by 1; results in the
                value of v after it is incremented.} \cr
    \bigskip

    \+& \tt --& \tt v-- \cr
    \+&       & \vtop{\hsize=4.0in\noindent decrements v by 1; results in the
                value of v before it is decremented.} \cr
    \goodbreak
    \+& \tt   & \tt --v \cr
    \+&       & \vtop{\hsize=4.0in\noindent decrements v by 1; results in the
                value of v after it is decremented.} \cr
    \bigskip

    \+& Notes:& The unary + is not defined in \Small. \cr
    \+&       & \vtop{\hsize=4.0in\noindent The operators |++| and |--| modify
                the operand. The operand must be an {\it lvalue}.} \cr

\def\tilde{\lower2pt\hbox{{\tt\char126}}\ignorespaces}
\def\hatop{\lower2pt\hbox{{\tt\char94}}\ignorespaces}
\def\shiftleft{{\tt\char60\char60}}
\def\shiftright{{\tt\char62\char62}}
\def\shiftrightu{{\tt\char62\char62\char62}}

\subsection{Bit manipulation}
    \+& \tt \tilde & \tt \tilde e \cr
    \+&       & results in the one's complement of e. \cr
    \bigskip

    \+& \shiftright & \tt e1 \shiftright\ e2 \cr
    \+&       & \vtop{\hsize=4.0in\noindent results in the {\it arithmetic\/} shift
                to the right of e1 by e2 bits. The shift operation is signed:
                the leftmost bit of e1 is copied to vacant bits in the
                result.} \cr
    \bigskip\goodbreak

    \+& \shiftrightu & \tt e1 \shiftrightu\ e2 \cr
    \+&       & \vtop{\hsize=4.0in\noindent results in the {\it logical\/} shift to
                the right of e1 by e2 bits. The shift operation is unsigned:
                the vacant bits of the result are filled with zeros.} \cr
    \bigskip\goodbreak

    \+& \shiftleft & \tt e1 \shiftleft\ e2 \cr
    \+&       & \vtop{\hsize=4.0in\noindent results in the value of e1 shifted
                to the left by e2 bits; the rightmost bits are set to zero.
                There is no distinction between an arithmetic and a logical
                left shift} \cr
    \bigskip

    \+& \tt \& & \tt e1 \& e2 \cr
    \+&       & results in the bitwise logical ``and'' of e1 and e2. \cr
    \bigskip\goodbreak

    \+& \vbar & \tt e1 \vbar\ e2 \cr
    \+&       & results in the bitwise logical ``or'' of e1 and e2. \cr
    \bigskip\goodbreak

    \+& \hatop & \tt e1 \hatop\ e2 \cr
    \+&       & results in the bitwise ``exclusive or'' of e1 and e2. \cr
    \goodbreak

%\vfil\eject%???
\subsection{Assignment}
   The result of an assignment expression is the value of the left
   operand after the assignment.
   \marginbox{-10}{Tag names: \xrefn{p.tagnames}}The left operand may not be tagged.
   \bigskip

    \+& \tt = & \tt v = e \cr
    \+&       & assigns the value of e to variable v. \cr
    \smallskip
                \sidx{Array assignment}
    \+&       & \vtop{\hsize=4.0in\noindent If ``{\tt v}'' is an array, it must have
                an explicit size and ``{\tt e}'' must be an array of the same size;
                ``{\tt e}'' may be a string or a literal array.} \cr
    \bigskip\goodbreak

    \+& Note: & \vtop{\hsize=4.0in\noindent  the following operators combine an
                assignment with an arithmetic or a bitwise operation; the
                result of the expression is the value of the left operand
                after the arithmetic or bitwise operation.} \cr
    \bigskip

    \+& \tt += & \tt v += e \cr
    \+&       & increments v with a. \cr \goodbreak

    \+& \tt -= & \tt v -= e \cr
    \+&       & decrements v with e \cr \goodbreak

    \+& \tt *= & \tt v *= e \cr
    \+&       & multiplies v with e \cr

    \+& \tt /= & \tt v /= e \cr
    \+&       & divides v by e. \cr

    \+& \tt \%= & \tt v \%= e \cr
    \+&       & assigns the remainder of the division of v by e to v. \cr

    \+& \tt \shiftright= & \tt v \shiftright= e \cr
    \+&       & shifts v arithmetically to the right by e bits.\cr

    \+& \tt \shiftrightu= & \tt v \shiftrightu= e \cr
    \+&       & shifts v logically to the right by e bits. \cr

    \+& \tt \shiftleft= & \tt v \shiftleft= e \cr
    \+&       & shifts v to the left by e bits. \cr \goodbreak

    \+& \tt \&= & \tt v \&= e \cr
    \+&       & applies a bitwise ``and'' to v and e and assigns the result to v. \cr \goodbreak

    \+& \tt \vbar= & \tt v \vbar= e \cr
    \+&       & applies a bitwise ``or'' to v and e and assigns the result to v. \cr \goodbreak

    \+& \tt \hatop= & \tt v \hatop= e \cr
    \+&       & applies a bitwise ``exclusive or'' to v and e and assigns the result to v. \cr
    \goodbreak


\subsection{Relational}
\xrdef{p.op.relational}
  A logical ``false'' is represented by an integer value of 0; a
  logical ``true'' is represented by any value other than 0. Value results of
  relational expressions are either 0 or 1, and their tag is set to ``bool''.

  \bigskip

    \+& \tt == & \tt e1 == e2 \cr
    \+&       & results in a logical ``true'' if e1 is equal to e2. \cr
    \bigskip\goodbreak

    \+& \tt !=    & \tt e1 != e2 \cr
    \+&       & results in a logical ``true'' if e1 differs from e2. \cr
    \bigskip\goodbreak

    \sidx{Chained relational operators}
    \+& Note: & \vtop{\hsize=4.0in\noindent  the following operators may be
                ``chained'', as in the expression ``{\tt e1 \char60= e2 \char60= e3}'',
                with the semantics that the result is ``1'' if {\it all\/}
                individual comparisons hold and ``0'' otherwise.} \cr
    \bigskip

    \+& \tt \char60 & \tt e1 \char60\ e2 \cr
    \+&       & results in a logical ``true'' if e1 is smaller than e2. \cr
    \bigskip\goodbreak

    \+& \tt \char60= & \tt e1 \char60= e2 \cr
    \+&       & results in a logical ``true'' if e1 is smaller than or equal to e2. \cr
    \bigskip\goodbreak

    \+& \tt \char62 & \tt e1 \char62\ e2 \cr
    \+&       & results in a logical ``true'' if e1 is greater than e2. \cr
    \bigskip\goodbreak

    \+& \tt \char62= & \tt e1 \char62= e2 \cr
    \+&       & results in a logical ``true'' if e1 is greater than or equal to e2. \cr
    \bigskip\goodbreak


\subsection{Boolean}
\xrdef{p.op.boolean}
  A logical ``false'' is represented by an integer value of 0; a
  logical ``true'' is represented by any value other than 0. Value results of
  Boolean expressions are either 0 or 1, and their tag is set to ``bool''.

  \bigskip

    \+& \tt ! & \tt !e \cr
    \+&       & results to a logical ``true'' if e was logically ``false''. \cr
    \bigskip\goodbreak

    \+& \tt \vbar\vbar & \tt e1 \vbar\vbar\ e2 \cr
    \+&       & \vtop{\hsize=4.0in\noindent  results to a logical ``true'' if
                either e1 or e2 (or both) are logically ``true''. The
                expression e2 is only evaluated if e1 is logically
                ``false''.} \cr
    \bigskip\goodbreak

    \+& \tt \&\& & \tt e1 \&\& e2 \cr
    \+&       & \vtop{\hsize=4.0in\noindent results to a logical ``true'' if
                both e1 and e2 are logically ``true''. The expression e2 is
                only evaluated if e1 is logically ``true''.} \cr \goodbreak

\subsection{Miscellaneous}
    \+& \tt [\hskip 2pt] & \tt a[e] \cr
    \+&       & array index: results to {\it cell\/} e from array a. \cr
    \bigskip%\goodbreak

    \+& \tt |{|\hskip 2pt|}| & \tt |a{e}| \cr
    \+&       & array index: results to {\it character\/} e from ``packed'' array a. \cr
    \bigskip\goodbreak

    \+& \tt (\hskip 2pt) & \tt f(e1,e2,...eN) \cr
    \+&       & \vtop{\hsize=4.0in\noindent results to the value returned by the
                 function f. The function is called with the arguments e1, e2,
                 \dots eN. The order of evaluation of the arguments is
                 undefined (an implementation may choose to evaluate function
                 arguments in reversed order).} \cr
    \bigskip\goodbreak

    \+& \tt ? : & \tt e1 ? e2 : e3 \cr
    \+&       & \vtop{\hsize=4.0in\noindent results in either e2 or e3,
                depending on the value of e1. The conditional expression is a
                compound expression with a two part operator, |?| and |:|.
                Expression e2 is evaluated if e1 is logically ``true'', e3 is
                evaluated if e1 is logically ``false''.} \cr
    \bigskip\goodbreak

    \+& \tt : & \tt {\it tagname}: e \cr        \sidx{Tag name}[override@\midtilde\ override]
    \+&       & \vtop{\hsize=4.0in\noindent tag override; the value of
                the expression e does not change, but its tag changes.
                See \xref{p.tagnames} for more information.} \cr

    \bigskip

    \+& \tt , & \tt e1, e2 \cr
    \+&       & \vtop{\hsize=4.0in\noindent results in e2, e1 is evaluated
                before e2. If used in function argument lists or a conditional
                expression, the comma expression must be surrounded by
                parentheses.} \cr
    \bigskip

    \+& \tt defined & \tt defined s \cr
    \+&       & \vtop{\hsize=4.0in\noindent results in the value 1 if the symbol
                is defined. The symbol may be a constant (\xref{p.constants}),
                or a global or local variable.} \cr
    \bigskip\goodbreak

    \+& \tt sizeof & \tt sizeof s \cr \xrdef{p.op.sizeof} \sidx{sizeof operator}
    \+&       & \vtop{\hsize=4.0in\noindent results in the size in ``elements''
                of the specified variable. For simple variables and for arrays
                with a single dimension, an element is a cell. For multi-dimensional
                arrays, the result is the number of array elements in that dimension
                ---append {\tt []} to the array name to indicate a lower\slash more minor dimension.
                If the size of a variable is unknown, the result is zero.\lbreak
                When used in a default value for a function argument, the expression
                is evaluation at the point of the function call, instead of in the
                function definition.} \cr
    \bigskip\goodbreak

    \+& \tt tagof & \tt tagof s \cr \xrdef{p.op.tagof} \sidx{tagof operator}
    \+&       & \vtop{\hsize=4.0in\noindent results in the a unique number that
                represents the tag of the variable, the constant, the function
                result or the tag label.\lbreak
                When used in a default value for a function argument, the expression
                is evaluation at the point of the function call, instead of in the
                function definition.} \cr
    \bigskip\goodbreak

    \+& \tt char & \tt e char \cr \xrdef{p.op.char}
    \+&       & \vtop{\hsize=4.0in\noindent results the number of cells that
                are needed to hold a packed array of e characters.} \cr
\sidx[end]{Operators}

\vfill
\subsection{Operator precedence}
\xrdef{p.op.precedence} \sidx{Precedence table} \sidx{Operator precedence}

The table beneath groups operators with equal precedence, starting with
the operator group with the highest precedence at the top of the table.

If the expression evaluation order is not explicitly established by
parentheses, it is determined by the association rules. For example: |a*b/c|
is equivalent with |(a*b)/c| because of the left-to-right association, and
|a=b=c| is equivalent with |a=(b=c)|.

\eject % ???

\bigskip
{
 \def\!{\tabalign\strut\vrule\ }%
 \def\nlnorule{&\strut\vrule\cr}%
 \def\nl{\nlnorule                      % rightmost vertical line
         \vskip 0pt minus 0.4pt\hrule   % horizontal line, may move upwards
         \goodbreak\vskip -0.4pt\hrule  % possible break, re-do horizontal line
         \vskip 0pt minus 0.4pt}%       % may move upward
 \sevenrm
 \offinterlineskip % for vertical lines

 \settabs\+\bf \hskip 0.2\hsize & \hskip 0.6\hsize & \hskip 0.2\hsize &\cr
 \hrule
\! \tt ()   & function call                & left-to-right \nlnorule
\! \tt []   & array index (cell)           &               \nlnorule
\! \tt |{}| & array index (character)      &               \nl
% ---------------------------------------------------------
\! \tt !    & logical not                  & right-to-left \nlnorule
\! \tt \tilde & one's complement           &               \nlnorule
\! \tt -    & two's complement (unary minus)&              \nlnorule
\! \tt ++   & increment                    &               \nlnorule
\! \tt --   & decrement                    &               \nlnorule
\! \tt :    & tag override                 &               \nlnorule
\! \tt char & convert number of packed characters to cells &\nlnorule
\! \tt defined & symbol definition status  &               \nlnorule
\! \tt sizeof & symbol size in ``elements''&               \nlnorule
\! \tt tagof & unique number for the tag   &               \nl
% ---------------------------------------------------------
\! \tt *        & multiplication           & left-to-right \nlnorule
\! \tt /        & division                 &               \nlnorule
\! \tt \%       & modulus                  &               \nl
% ---------------------------------------------------------
\! \tt +        & addition                 & left-to-right \nlnorule
\! \tt -        & subtraction              &               \nl
% ---------------------------------------------------------
\! \shiftright  & arithmetic shift right   & left-to-right \nlnorule
\! \shiftrightu & logical shift right      &               \nlnorule
\! \shiftleft   & shift left               &               \nl
% ---------------------------------------------------------
\! \tt \&   & bitwise and                  & left-to-right \nl
% ---------------------------------------------------------
\! \tt \char94 & bitwise exclusive or      & left-to-right \nl
% ---------------------------------------------------------
\! \vbar& bitwise or                       & left-to-right \nl
% ---------------------------------------------------------
\! \tt \char60  & smaller than             & left-to-right \nlnorule
\! \tt \char60= & smaller than or equal to &               \nlnorule
\! \tt \char62  & greater than             &               \nlnorule
\! \tt \char62= & greater than or equal to &               \nl
% ---------------------------------------------------------
\! \tt ==   & equality                     & left-to-right \nlnorule
\! \tt !=   & inequality                   &               \nl
% ---------------------------------------------------------
\! \tt \&\& & logical and                  & left-to-right \nl
% ---------------------------------------------------------
\! \vbar\vbar& logical or                  & left-to-right \nl
% ---------------------------------------------------------
\! \tt ? :  & conditional                  & right-to-left \nl
% ---------------------------------------------------------
\! \tt =    & assignment                   & right-to-left \nlnorule
\! \tt *=  /=  \%=  +=  -=  \shiftright=  \shiftrightu=  \shiftleft=  \&=  \char94=  \vbar= & &  \nl
% ---------------------------------------------------------
\! \tt ,    & comma                        & left-to-right \nl
}
% +---------------------------------------------------------------+
% |  ()   function call                           left-to-right   |
% |  []   array index (cell)                                      |
% |  {}   array index (character)                                 |
% +---------------------------------------------------------------+
% |  !    logical not                             right-to-left   |
% |  ~    one's complement                                        |
% |  -    two's complement (unary minus)                          |
% |  ++   increment                                               |
% |  --   decrement                                               |
% |  char convert number of packed characters to cells            |
% |  defined  symbol definition status                            |
% |  sizeof   symbol size in elements                             |
% |  tagof    unique number for the tag                           |
% +---------------------------------------------------------------+
% |  *    multiplication                          left-to-right   |
% |  /    division                                                |
% |  %    modulus                                                 |
% +---------------------------------------------------------------+
% |  +    addition                                left-to-right   |
% |  -    subtraction                                             |
% +---------------------------------------------------------------+
% |  >>   shift right                             left-to-right   |
% |  >>>  logical shift right                                     |
% |  <<   shift left                                              |
% +---------------------------------------------------------------+
% |  &    bitwise and                             left-to-right   |
% +---------------------------------------------------------------+
% |  ^    bitwise exclusive or                    left-to-right   |
% +---------------------------------------------------------------+
% |  |    bitwise or                              left-to-right   |
% +---------------------------------------------------------------+
% |  <    smaller than                            left-to-right   |
% |  <=   smaller than or equal to                                |
% |  >    greater than                                            |
% |  >=   greater than or equal to                                |
% +---------------------------------------------------------------+
% |  ==   equality                                left-to-right   |
% |  !=   inequality                                              |
% +---------------------------------------------------------------+
% |  &&   logical and                             left-to-right   |
% +---------------------------------------------------------------+
% |  ||   logical or                              left-to-right   |
% +---------------------------------------------------------------+
% |  ? :  conditional                             right-to-left   |
% +---------------------------------------------------------------+
% |  =    assignment                              right-to-left   |
% |  *=  /=  %=  +=  -=  <<=  >>=  >>>=  &=  ^=  |=               |
% +---------------------------------------------------------------+
% |  ,    comma                                   left-to-right   |
% +---------------------------------------------------------------+
\vfill\eject
\footnotenumber=0%

\chapter{Statements}
\xrdef{p.statements} \sidx[begin]{Statements}

A statement may take one or more lines, whereas one line may contain two or
more statements.

Control flow statements (|if|, |if|--|else|, |for|, |while|, |do|--|while|
and |switch|) may be nested.


\beginlist{35pt}
\item Statement label: \xrdef{p.stmt.label}
        \noindent\marginbox0{Identifiers: \xrefn{p.syntax.identifiers}}%
        A label consists of an identifier followed by a colon (|:|). A
        label is a ``jump target'' of the |goto| statement.

        Each statement may be preceded by a label. There must be a statement
        after the label; an empty statement is allowed.

        The scope of a label is the function in which it is declared (a |goto|
        statement cannot therefore jump out off the current function to
        another function).

\item Compound statement: \xrdef{p.stmt.compound}
        A compound statement is a series of zero or more statements surrounded
        by braces (|{| and |}|). The final brace (|}|) should not be followed
        by a semicolon. Any statement may be replaced by a compound statement.
        A compound statement is also called a block. A compound statement with
        zero statements is a special case, and it is called an ``empty
        statement''.

\item Expression statement:
        Any expression becomes a statement when a semicolon (|;|) is
        appended to it. An expression also becomes a statement when only white
        space follows it on the line and the expression cannot be extended over
        the next line.

\item Empty statement: \xrdef{p.stmt.empty}
        An empty statement performs no operation and consists of a compound
        block with zero statements; that is, it consists of the tokens ``|{ }|''.
        Empty statements are used in control flow statements if there is
        no action (e.g. |while (!iskey()) {}|) or when defining a label
        just before the closing brace of a compound statement. An empty
        statement does not end with a semicolon.

\item assert {\it expression\/}: \xrdef{p.stmt.assert}
        \noindent\marginbox0{Example: \xref{p.ex.fibonacci}}%
        Aborts the program with a run-time error if the expression evaluates
        to logically ``false''.

\item break:
        \noindent\marginbox0{Example: \xref{p.ex.queue}}%
        Terminates and exits the smallest enclosing |do|, |for| or
        |while| statement from any point within the loop
        other than the logical end. The |break| statement moves program
        control to the next statement outside the loop.

\item continue:
        Terminates the current iteration of the smallest enclosing |do|, |for|
        or |while| statement and moves program control to the condition part
        of the loop. If the looping statement is a |for| statement, control
        moves to the third expression in the |for| statement (and thereafter
        to the second expression).

\item do {\it statement\/} while ( {\it expression\/} ):
        Executes a statement before the condition part (the |while| clause) is
        evaluated. The statement is repeated while the condition is logically
        ``true''. The statement is at least executed once.

\item exit {\it expression\/}:
        \sidx{Host application}%
        Abort the program. The expression is optional, but it must start on the
        same line as the |exit| statement if it is present. The |exit|
        instruction returns the expression value (plus the expression tag) to
        the host application, or zero if no exit expression is present. The
        significance and purpose of exit codes is implementation defined.

\item for ( {\it expression 1\/} ; {\it expression 2\/} ; {\it expression 3\/} ) {\it statement\/}:
        \xrdef{p.stmt.for}
        All three expressions are optional.
        \marginbox{-5}{Example: \xref{p.ex.sieve}}%
        \marginbox{30}{Variable declarations: \xrefn{p.data.declarations}}%
        \beginlist{60pt}
        \list{\it expression 1}
                Evaluated only once, and before entering the loop. This
                expression may be used to initialize a variable.
                This expression may also hold a variable declaration, using the
                |new| syntax. A variable declared in this expression exists
                only in the |for| loop.

        \list{\it expression 2}
                Evaluated before each iteration of the loop and ends the loop
                if the expression results to logically ``false''. If omitted,
                the result of expression 2 is assumed to be logically
                ``true''.

        \list{\it expression 3}
                Evaluated after each execution of the statement. Program
                control moves from expression 3 to expression 2 for the next
                (conditional) iteration of the loop.
        \endlist
        The statement |for( ; ; )| is equivalent with |while (true)|.

\item goto {\it label\/}:
        Moves program control (unconditionally) to the statement that follows
        the specified label. The label must be within the same function as the
        goto statement (a goto statement cannot jump out of a function).

\item if ( {\it expression\/} ) {\it statement 1\/} else {\it statement 2\/}:
        \xrdef{p.stmt.if}
        \noindent\marginbox0{Example: \xref{p.ex.gcd}}%
        Executes statement 1 if the expression results to logically ``true''.
        The |else| clause of the |if| statement is optional. If the expression
        results to logically ``false'' and an |else| clause exists, the
        statement associated with the |else| clause (statement 2) executes.

        When |if| statements are nested and |else| clauses are present, a
        given |else| is associated with the closest preceding |if| statement
        in the same block.

\item return {\it expression\/}:
        \noindent\marginbox0{Example: \xref{p.ex.fibonacci}}%
        Terminates the current function and moves program control to the
        statement following the calling statement. The value of the expression
        is returned as the function result.

        The expression is optional, but it must start on the same line as the
        |return| statement if it is present. If absent, the value of the
        function is zero.

\item sleep {\it expression\/}:
        \xrdef{p.stmt.sleep}%
        \sidx{Host application} \sidx{Latent function} \sidx{Functions}[latent \midtilde]%
        Abort the program, but leave it in a re-startable state. The expression
        is optional. If included, the |sleep| instruction returns the expression
        value (plus the expression tag) to the host application. The
        significance and purpose of exit codes\slash tags is implementation
        defined; typically, an application uses the |sleep| instruction to allow
        for light-weight multi-tasking of several concurrent \Small\ programs,
        or to implement ``latent'' functions.

\item switch ( {\it expression\/} ) {\tt $\{$} {\it case list\/} {\tt $\}$}:
        \xrdef{p.stmt.switch}
        Transfers control to different statements within the switch body
        depending on the value of the switch expression. The body of the
        |switch| statement is a compound statement, which contains a
        series of ``case clauses''.

        Each ``case clause'' starts with the keyword |case| followed by a
        constant list and {\it one\/} statement. The constant list is a series
        of expressions, separated by comma's, that each evaluates to a constant
        value. The constant list ends with a colon. To specify a ``range''
        in the constant list, separate the lower and upper bounds of the
        range with a double period (``|..|''). An example of a range is:
        ``|case 1..9:|''.

        The |switch| statement moves control to a ``case clause'' if the value
        of one of the expressions in the constant list is equal to the
        |switch| expression result.

        The ``default clause'' consists of the keyword |default| and a colon.
        The default clause is optional, but if it is included, it must be
        the last clause in the switch body. The |switch| statement moves
        control to the ``default clause'' is executed if none of the case
        clauses match the expression result.

        {\bf Example}:\codeidx{weekday}
\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
switch (weekday(12,31,1999))
    {
    case 0, 1:          /* 0 == Saturday, 1 == Sunday */
        print("weekend")
    case 2:
        print("Monday")
    case 3:
        print("Tuesday")
    case 4:
        print("Wednesday")
    case 5:
        print("Thursday")
    case 6:
        print("Friday")
    default:
        print("invalid week day")
    }
|endverbatim


\item while ( {\it expression\/} ) {\it statement\/}: \xrdef{p.stmt.while}
        \noindent\marginbox0{Example: \xref{p.ex.gcd}}%
        Evaluates the expression and executes the statement if the expression
        result yields logically ``true''. After the statement has executed,
        program control returns to the expression again. The statement is thus
        executed while the expression is true.
\endlist
\sidx[end]{Statements}


\chapter{Directives}
%-------------------
\xrdef{p.directives} \sidx[begin]{Directives}

All directives must appear first on a line (they may be preceded by white
space, but not by any other characters). All directives start with the
character |#| and the complete instruction may not span more than one line.


\beginlist{35pt}
\item \#assert {\it constant expression\/}: \xrdef{p.assert.p}
        \codeidx{\#assert}
        Issues a compile time error if the supplied constant expression
        evaluates to zero.
        \marginbox0{See also ``Predefined constants'' on page \xrefn{p.predefined.constants}}%
        The |#assert| directive is most useful to guard against implementation
        defined constructs on which a program may depend, such as the cell size
        in bits, or the number of packed characters per cell.

\item \#define {\it pattern ~ replacement\/}:
        \sidx{Text substitution} \sidx{Preprocessor}[macro@\midtilde\ macro] \sidx{Macro}
        \codeidx{\#define}
        Defines a text substitution macro. The pattern is matched to all lines
        read from the source files; the section that match are replaced by the
        replacement text. The pattern and the replacement texts may contain
        parameters, denoted by ``|%0|'' to ``|%9|''. See \xref{p.preprocessor}
        for details and examples on text substitution.

\item \#emit {\it opcode, parameters\/}:
        \codeidx{\#emit}
        The |#emit| directive serves as an inline assembler. It is currently
        used only for testing the abstract machine.

\item \#endinput:
        \codeidx{\#endinput}
        Closes the current file and thereby ignores all the text below the
        |#endinput| directive.

\item \#include {\it filename\/} or $<${\it filename\/}$>$:
        \codeidx{\#include}
        Inserts the contents of the specified file at the current position
        within the current file. A filename between angle brackets (``$<$'' and ``$>$'')
        refers to a system file; the \Small\ parser (compiler or interpreter) will
        search for such files only in a preset list of directories and not in
        the ``current'' directory. Filenames that are unquoted or that appear in
        double quotes are normal include files, for which a \Small\ parser
        will look in the currect directory first.

        The \Small\ parser first attempts to open the file with the sepcified
        name. If that fails, it tries appending the extensions ``|.INC|'' and ``|.SMA|''
        to the filename (in that order).
        The proposed default extension of include files is ``|.INC|''.

\item \#file {\it name\/}: \xrdef{p.file.p}
        \codeidx{\#file}
        The current filename. This directive is used implicitly by the text
        preprocessor; there is usually no need to set a filename explicitly.

\item \#if {\it constant expression\/}, \#else, \#endif: \xrdef{p.if.p}
        \codeidx{\#if}
        Portions of a program may be parsed or be ignored depending on certain
        conditions. The \Small\ parser (compiler or interpreter) generates code
        only for those portions for which the condition is true.

        The directive |#if| must be followed by a constant expression. To
        check whether a variable or constant is defined, use the |defined|
        operator.

        The |#else| directive reverses the parsing state. If the parser
        ignored lines up to the directive, it starts parsing and if it parsed
        lines, it stops parsing. There should only be one |#else| associated
        with each |#if|, but a \Small\ parser need not impose this restriction.

        The |#endif| directive terminates a program portion that is parsed
        conditionally. Conditional directives can be nested and each |#if|
        directive must be ended by an |#endif| directive.

\item \#line {\it number\/}: \xrdef{p.line.p}
        \codeidx{\#line}
        The current line number (in the current file). This directive is used
        implicitly by the text preprocessor; there is usually no need to set
        the line number explicitly.

\item \#pragma {\it extra information\/}:
        \codeidx{\#pragma}
        A pragma is a hook for a parser to specify additional settings, such
        as warning levels or extra capabilities. Common pragmas are:

        \beginlist{35pt}
        \list{\tt \#pragma align} \lbreak \xrdef{p.align} \sidx{Alignment (variables)}
                Aligns the next declaration to the offset set with the alignment
                compiler option. Some (native) functions may perform better
                with parameters that are passed by reference when these are
                on boundaries of 8, 16, or even 32 bytes.

                Putting the |#pragma align| line in front of a declaration of
                a global or a static variable aligns this variable to the
                boundary set with the compiler option. Note that this |#pragma|
                aligns only the variable that immediately follows the |#pragma|.
                The alignment of subsequent variables depends on the size and
                alignment of the variables that precede it. For example, if a
                global array variable of 2 cells is aligned on a 16-byte
                boundary and a cell is 4 bytes, the next global variable is
                located 8 bytes further.

                Putting the |#pragma align| line in front of a declaration of
                a function will align the stack frame of that function to the
                boundary specified earlier, with the result that the first
                local, non-``static'', variable is aligned to that boundary.
                The alignment of subsequent variables depends on the size and
                alignment of the variables that precede it. In practice, to
                align a local non-static variable, you must align the function's
                stack frame and declare that variable before any other variables.

        \list{\tt \#pragma compress \it value} \lbreak \xrdef{p.compress.p} \sidx{Compact encoding} \sidx{P-code}
                The \Small\ parser may write the generated P-code in compact
                or plain (``non-compact'') encoding. The default depends on the
                parser configuration (and, perhaps, user settings). This pragma
                allows the script writer to override the default and force compact
                encoding (when {\it value\/} is non-zero) or to force plain encoding
                (when {\it value\/} is zero). Especially toggling compact encoding
                off (forcing plain encoding) is useful, because the \Small\ parser
                may be unable to compile a particular script in ``compact encoding''
                mode.

        \list{\tt \#pragma ctrlchar \it character} \lbreak \xrdef{p.ctrlchar}
                \noindent\marginbox0{Escape character: \xrefn{p.def.ctrlchar}}%
                Defines the character to use to indicate the start of a
                ``escape sequence''. By default, the control character is
                ``|\|''.

                For example \lbreak
                |    #pragma ctrlchar '$'|
        \list{\tt \#pragma dynamic \it value} \lbreak \xrdef{p.pdynamic}
                Sets the size, in cells, of the memory block for dynamic data
                (the stack and the heap) to the value specified by the
                expression. The default size of the dynamic data block is
                implementation defined. An implementation may also choose to
                grow the block on an as-needed basis (see the host program's
                documentation, or the ``Implementor's Guide'' for details).

        \list{\tt \#pragma library \it name} \lbreak \xrdef{p.library}
                Sets the name of the (dynamically linked) library or module
                that contains required native functions.

        \list{\tt \#pragma pack \it value} \lbreak \xrdef{p.pack.p}
                If |value| is zero, packed literal strings start with ``|!"|''
                and unpacked literal strings with only a double quote
                (``|"|''), as described in this manual at \xref{p.const.string}.
                If |value| is non-zero, the syntax for packed and unpacked
                literal strings is swapped: literal strings that start with
                a double quote are packed and literal strings that start
                with ``|!"|'' are unpacked.

        \list{\tt \#pragma rational {\it tagname}({\it value})} \lbreak \xrdef{p.rational.p}
                Enables support for rational numbers (see \xref{p.rational}).
                The |tagname| is the name pf the tag that rational numbers will
                have; typically one chooses the names ``float'' or ``fixed''.
                The value in parantheses behind |tagname| is optional: if it
                is omitted, a rational number is stored as a ``floating point''
                value according to the IEEE 754 norm; if it is present, a
                rational number is a fixed precision number (``scaled integer'')
                with the specified number of decimals.

        \list{\tt \#pragma semicolon \it value} \lbreak \xrdef{p.semicolon.p}
                If |value| is zero, no semicolon is required to end a statement
                if that statement is last on a line. Semicolons are still needed
                to separate multiple statements on the same line.

                When semicolons are optional (the default), a postfix operator
                (one of ``|++|'', ``|--|''  and ``|char|'') may not be the first token
                on a line.

        \list{\tt \#pragma tabsize \it value} \lbreak \xrdef{p.tabsize.p}
                The number of characters between two consecutive \smallcaps{tab}
                positions. The default value is 8. You may need to set the
                \smallcaps{tab} size to avoid warning 217 (loose indentation)
                if the source code is indented alternately with spaces and
                with \smallcaps{tab} characters. Alternatively, by setting the
                ``|tabsize|'' pragma to zero, the parser will no longer issue
                warning 217.

        \list{\tt \#pragma unused \it symbol} \lbreak \xrdef{p.unused.p}
                Marks the named symbol as ``used''. Normally, the \Small\ parser
                warns about unused variables and unused local constants. In
                most situations, these variables and constants are redundant,
                and it is better to remove them for the sake of code clarity.
                Especially in the case of local constants, it may, however,
                be better (or required) to keep the constant definitions. This
                |#pragma| then permits to mark the symbol (variable or constant)
                as ``used'', and avoid a parser warning.

                The |#pragma| must appear {\it after\/} the symbol declaration
                ---but it need not appear immediately after the declaration.

                Multiple symbol names may appear in a single |#pragma|; the
                symbols must be separated by commas.
        \endlist

\item \#undef {\it name\/}:
        \codeidx{\#undef} \sidx{Macro}[prefix@\midtilde\ prefix]
        Removes a text substitution macro. The ``name'' parameter must be the
        macro ``prefix'' ---the alphanumeric part of the macro.
        See \xref{p.preprocessor} for details and examples on text substitution.
\endlist
\sidx[end]{Directives}


\vfill\eject
\footnotenumber=0%

\chapter{Proposed function library}
\xrdef{p.functions.proposed}
\sidx{Standard function library} \sidx{Function library} \sidx{Functions}[standard library \midtilde]

\sidx{Host application}%
Since \Small\ is targeted as an application extension language, most of the
functions that are accessible to \Small\ programs will be specific to the host
application. Nevertheless, a small set of functions may prove useful to many
environments.

\subsection{Core functions}
\xrdef{p.functions.core}
The ``core'' module consists of a set of functions that support the language
itself. Several of the functions are needed to pull arguments out of a variable
argument list (see \xref{p.var.args}).

Since there are only few functions, I have opted to arrange them per category,
rather than alphabetically.

\beginlist{35pt}
\item heapspace():
  Return the free space on the heap. The stack and the heap occupy a shared
  memory area.
\item funcidx(const name[]):
  \sidx{Functions}[index@\midtilde\ index]\sidx{Public}[functions@\midtilde\ functions]
  Returns the index of the named public function.
  \sidx{Host application} %\marginbox0{amx_Exec: \xrefn{p.amx.Exec}}%
  A host application runs a public function from the script by passing the public
  function's index to |amx_Exec()|. With this function, the script can query
  the index of a public function, and thereby return the ``next function to
  call'' to the application.

  If no public function with the given name exists, |funcidx| returns $-1$.

\dingbatseparator

\item numargs():
  Return the number of arguments passed to a function; |numargs()| is useful
  inside functions with a variable argument list.
\item getarg(arg, index=0):
  Retrieve an argument from a variable argument list. Parameter |arg| is the
  argument sequence number, use 0 for first argument. When the argument is an
  array, the |index| parameter specifies the index into the array. The return
  value is the retrieved argument.
\item setarg(arg, index=0, value):
  Set the value of an argument from a variable argument list. Parameter |arg| is
  the argument sequence number, use 0 for first argument. When the
  argument is an array, the |index| parameter specifies the index into the
  array. The return value is |false| if the argument or the index are invalid,
  and |true| on success.

\dingbatseparator

\sidx{Packed string} \sidx{Unpacked string} \sidx{String}[packed \midtilde] \sidx{String}[unpacked \midtilde]
\item strlen(const string[]):
  Returns the length of a string, either packed or unpacked, as the number
  of characters (not the number of cells).
\item strpack(dest[], const source[]):
  Copy a string from |source| to |dest| where the destination string will
  be in packed format. The source string may either be a packed or an
  unpacked string.
\item strunpack(dest[], const source[]):
  Copy a string from |source| to |dest| where the destination string will
  be in unpacked format. The source string may either be a packed or an
  unpacked string.
\item tolower(c):
  Returns the character code of the lower case letter of ``|c|'' if there is
  one, or the character code of ``|c|'' if the letter ``|c|'' has no lower
  case equivalent.
\item toupper(c):
  Returns the character code of the upper case letter of ``|c|'' if there is
  one, or the character code of ``|c|'' if ``|c|'' has no upper case
  equivalent.

\dingbatseparator

\item swapchars(c):
  Returns the value of |c| where all bytes in the cell are swapped (the lowest
  byte becomes the highest byte).
\item random(max):
  Returns a pseudo-random number in the range |0| -- |max-1|.
\item max(value1, value2):
  Returns the higher value of |value1| and |value2|.
\item min(value1, value2):
  Returns the lower value of |value1| and |value2|.
\item clamp(value, min=cellmin, max=cellmax):
  Returns |value| if it is in the range |min| -- |max|; returns |min| if
  |value| is lower than |min|; returns |max| if |value| is higher than |max|.

\dingbatseparator

Properties are general purpose names or values. The property list routines
maintain a list of these name/value pairs that is shared among all abstract
machines. The property list is therefore a way for concurrent abstract machines
to exchange information.

All ``property maintenance'' functions have an optional ``id'' parameter. You
can use this parameter to indicate which abstract machine the property belongs
to. (A host application that supports concurrent abstract machines will usually
provide each abstract machine with a unique id.) When querying (or deleting) a
property, the id value that you pass in is matched to the id values of the
list.

A property is identified with its ``abstract machine id'' plus {\it either\/}
a name {\it or\/} a value. The name-based interface allows you to attach a value
(e.g. the handle of an object) to a name of your choosing. The value-based
interface allows you to attach a string to a number. The difference between
the two is basically the search key versus the output parameter.

All property maintenance functions have a ``name'' and a ``value'' parameter.
Only one of this pair must be filled in. When you give the value, the
|getproperty| function stores the result in the |string| argument and the
|setproperty| function reads the string to store from the |string| argument.

The number of properties that you can add is limited only by available memory.

\item getproperty(id=0, const name[]=``'', value=cellmin, string[]=``''):
  Returns the value of a property when the |name| is passed in; fills in the
  |string| argument when the |value| is passed in. The |name| string may
  either be a packed or an unpacked string. If the property does not exist,
  this function returns zero.
\item setproperty(id=0, const name[]=``'', value=cellmin, const string[]=``''):
  Add a new property or change an existing property.
\item deleteproperty(id=0, const name[]=``'', value=cellmin):
  Returns the value of the property and subsequently removes it. If the
  property does not exist, the function returns zero.
\item existproperty(id=0, const name[]=``'', value=cellmin):
  Returns |true| if the property exists and |false| otherwise.
\endlist


\subsection{Console functions}
For testing purposes, the console functions that read user input and that
output strings in a scrollable window or on a standard terminal display are
often convenient.

\beginlist{35pt}
\item getchar(echo=true):
  Read one character from the keyboard and return it. The function can
  optionally echo the character on the console window.
\item getstring(string[], maxlength, bool:pack=false):
  Read a string from the keyboard. Function |getstring| stops reading when
  either the enter key is typed, or the maximum length is reached. The
  maximum length is in characters (not cells). The function can read both
  packed and unpacked strings. The return value is the number of characters
  read.
\item getvalue(base=10, end=`\hatop r', ...):
  Read a value (a signed number) from the keyboard. The |getvalue| function
  allows you to read in a numeric radix from 2 to 36 (the |base| parameter)
  with decimal radix by default.

  By default the input ends when the user types the enter key, but one or more
  different keys may be selected (the |end| parameter and subsequent). In the
  list of terminating keys, a positive number (like |'\r'|) displays the key
  and terminates input, and a negative number terminates input without
  displaying the terminating key.
\item print(const str[], foreground=-1, background=-1):
  Prints a simple string on the console. The foreground and background colours
  may be optionally set. See |CONSOLE.INC| for a list of colours.
\item printf(const format[], ...):
  Prints a string with embedded codes:
  \beginlist{2em} \compactlist
  \list{\tt \%c} print a character at this position
  \list{\tt \%d} print a decimal number at this position
  \list{\tt \%f} print a floating point number at this position
  \list{\tt \%r} print a fixed point number at this position
  \list{\tt \%s} print a character string at this position
  \endlist
  The |printf| function works similarly to the |printf| function of the
  C language.
\endlist

%??? date/time functions

\subsection{Fixed point arithmetic}
\sidx{Floating point arithmetic}\sidx{Fixed point arithmetic}
\xrdef{p.fixed.point}
\Small\ does not direcly support fixed point arithmetic. Support for fixed point
artihmetic is built on a set of native functions and user-defined operators.
A fixed point number in \Small\ is a 32-bit number with 3 decimals and a range
of $-2,147,482$ to $+2,147,482$.

To convert from integers to cells, use one of the functions |fixed| or
|fixedstr|. The function |fixed| creates a fixed point number with the same
integral value as the input value and a fractional part of zero. Function
|fixedstr| makes a fixed point number from a string, which can include a
fractional part.

To convert back from fixed point numbers to plain cells, use the functions
|fround| and |ffract|. Function |fround| is able to round upwards, to round
downwards (truncation) and to round to the nearest integer. Function |ffract|
gives the fractional part of a fixed point number, but still stores this as
a fixed point number.

Adding and subtracting operations on fixed point values can use the
conventional $+$ and $-$ operators. For multiplication and division, one must
use the |fmul| and |fdiv| functions.

\beginlist{35pt}
\def\tag#1{{#1}:}%
\item \tag{fixed}fixed(value):
  Create a fixed point number with the same (integral) value as the parameter
  |value|.
\item \tag{fixed}fixedstr(const string[]):
  Create a fixed point number from a string. The string may specify a
  fractional part, e.g., ``|123.45|''.
\item \tag{fixed}fmul(\tag{fixed}oper1, \tag{fixed}oper2):
  Multiply two fixed point numbers.
\item \tag{fixed}fdiv(\tag{fixed}dividend, \tag{fixed}divisor):
  Fixed point division.
\item \tag{fixed}ffract(\tag{fixed}value):
  Returns the fractional part if |value|.
\item fround(\tag{fixed}value, \tag{fround_method}method=fround_round):
  Round a fixed point number and return the value as a cell. The rounding
  method may be one of:
  \beginlist{65 pt}\compactlist
  \list{\tt fround_round} round to the nearest integer (default)
  \list{\tt fround_floor} round downwards
  \list{\tt fround_ceil} round upwards
  \list{\tt fround_tozero} round downwards for positive values and upwards for
        negative values (``truncate'')
  \endlist
  When rounding negative values upwards or downwards, note that $-2$ is
  considered smaller than $-1$.
\endlist

\subsection{DLL call interface}
The version of the abstract machine that is build as a Dynamic Link Library
for Microsoft Windows has a general purpose function to call a function from
any DLL in memory. Two companion functions load a DLL from disk into memory and
unload it. The functions have been set up so that it is possible to run the
same compiled script in both 16-bit and 32-bit versions of Microsoft Windows.

All string parameters may be in both packed or unpacked form.

\beginlist{35pt}
\item calldll(const dllname[], const function[], const typestr[], ...):
  Parameter |dllname| is the module name of the DLL, typically this is the same
  as the filename. If the DLL cannot be found, |calldll| tries again after
  appending ``|16|'' or ``|32|'' to the filename, depending on whether you run
  the 16-bit or the 32-bit version of the abstract machine. For example, if
  you set |dllname| to ``|USER|'', |calldl| connects to |USER| in the 16-bit
  version of the abstract machine and to |USER32| in the 32-bit version.

  Parameter |function| is the name of the function in the DLL. In the 16-bit
  version of, this name is case insensitive, but in the 32-bit version of
  Microsoft Windows, names of exported functions are case sensitive. In the
  32-bit version of the abstract machine, if |function| cannot be found,
  |calldll| appends an upper case ``|A|'' to the name and tries again ---many
  functions in 32-bit Windows exist in two varieties: ANSI and Unicode, and
  these functions are suffixed with an ``|A|'' or a ``|W|'' respectively. So
  if |function| is ``|MessageBox|'', |calldll| will call |MessageBox| in the
  16-bit version of Windows and |MessageBoxA| in the 32-bit version.

  The string parameter |typestr| indicates the number of arguments that the
  function (in the DLL) takes and what the types are. For every argument, you
  add one letter to the |typestr| string:
  \beginlist{2em}\compactlist
  \list{\tt h} a Windows ``handle'' (HWND, HDC, HPALETTE, HMEM, etc.)
  \list{\tt i} an integer with a ``native size'' (16-bit or 32-bit, depending
    on the ``bitness'' of the abstract machine).
  \list{\tt l} a 32-bit integer
  \list{\tt p} a packed string
  \list{\tt s} an unpacked string
  \list{\tt w} a 16-bit unsigned integer
  \endlist
  When the letter is in lower case, the corresponding parameter is passed ``by
  value''; when it is in upper case, it is passed ``by reference''. The
  difference between packed and unpacked strings is only relevant when the
  parameter is passed by reference.
\item loaddll(const dllname[]):
  Loads the specified DLL into memory (or increments its usage count it it were
  already loaded). The name in parameter |dllname| may contain
  a full path. If no path is specified, Microsoft Windows searches in its system
  directories for the DLL. Similarly to the |calldll| function, this function
  appends ``|16|'' or ``|32|'' to the DLL name if the DLL cannot be found, and
  then tries again.
\item freedll(const dllname[]):
  Decrements the DLL's usage count and, if the count becomes zero, removes the
  DLL from memory. The name in parameter |dllname| may contain a full path, but
  the path information is ignored. Similarly to the |calldll| function, this function
  appends ``|16|'' or ``|32|'' to the DLL name if the DLL cannot be found, and
  then tries again.
\item iswin32():
  Returns |true| if the abstract machine is the 32-bit version (running in a
  32-bit version of Microsoft Windows); returns |false| if the abstract machine
  is the 16-bit version (running either on Windows 3.1x or on any later version
  of Microsoft Windows).
\endlist


\vfill\eject
\footnotenumber=0%

\chapter{Pitfalls: differences from C}
\xrdef{p.pitfalls}
\beginlist{1em}
\list{\lbullet}
  \Small\ lacks the typing mechanism of C. \Small\ is an ``integer-only'' variety
  of C; there are no structures or unions, and floating point support must be
  implemented with user-defined operators and the help of native functions.

\list{\lbullet}
  \sidx{Floating point arithmetic}
  The accepted syntax for rational numbers is stricter than that of floating
  point values in C. Values like ``.5'' and ``6.'' are acceptable in C, but in \Small\
  one must write ``0.5'' and ``6.0'' respectively. In C, the decimal period is
  optional if an exponent is included, so one can write ``2E8''; \Small\ does not
  accept the upper case ``E'' (use a lower case ``e'') and it requires the
  decimal point: e.g. ``2.0e8''. See \xref{p.rational} for more information.

\list{\lbullet}
  \Small\ does not provide ``pointers''. For the purpose of passing function
  arguments by reference, \Small\ provides a ``reference'' argument,
  (\xref{p.function.args}). The ``placeholder'' argument replaces some uses
  of the NULL pointer (\xref{p.default.args}).

\list{\lbullet}
  \sidx{Binary radix} \sidx{Octal radix} \sidx{Hexadecimal radix}
  Numbers can have hexadecimal, decimal or binary radix. Octal radix is not
  supported. See ``Constants'' on \xref{p.constants}. Hexadecimal numbers must
  start with ``|0x|'' (a lower case ``x''), the prefix ``|0X|'' is invalid.

\list{\lbullet}
  The {\it final\/} dimension of a multi-dimensional array may have an
  unspecified length. In C, the {\it first\/} dimension may have an unspecified
  length. See \xref{p.multdim-array}.

\list{\lbullet}
  Escape sequences (``|\n|'', ``|\t|'', etc.) are the same, except for ``|\ddd|''
  where ``|ddd|'' represent three {\it decimal\/} digits, instead of the
  {\it octal\/} digits that C/\Cpp\ uses.
  The backslash (``|\|'') may be replaced with another symbol; see |#pragma ctrlchar|
  on \xref{p.ctrlchar} ---notably, previous versions of \Small\ used the caret
  (``|^|'') as the escape character.

\list{\lbullet}
  Cases in a |switch| statement are {\it not\/} ``fall through''. Only a single
  instruction may (and must) follow each |case| label. To execute multiple
  instructions, you must use a compound statement. The |default| clause of a
  |switch| statement must be the last clause of the |switch| statement. More
  on \xref{p.stmt.switch}.

\list{\lbullet}
  A |break| statement breaks out of loops only. In C/\Cpp, the |break| statement
  also ends a |case| in a |switch| statement. Switch statements are implemented
  differently in \Small\ (see \xref{p.stmt.switch}).

\list{\lbullet}
  \sidx{Array assignment}
  \Small\ supports ``array assignment'', with the restriction that both arrays
  must have the same size. For example, if ``|a|'' and ``|b|'' are both arrays
  with 6 cells, the expression ``|a = b|'' is valid. Next to literal strings,
  \Small\ also supports literal arrays, allowing the expression
  ``|a = {0,1,2,3,4,5}|'' (where ``|a|'' is an array variable with 6 elements).

\list{\lbullet}
  \codeidx{char}
  |char| is an operator, not a type. See \xref{p.op.char} and the tips on
  \xref{p.tips.strings}.

\list{\lbullet}
  |defined| is an operator, not a preprocessor directive. The |defined|
  operator in \Small\ operates on constants (with |const| and |enum|), global
  variables, local variables and functions.

\list{\lbullet}
  The |sizeof| operator returns the size of a variable in ``elements'', not in
  ``bytes''. An element may be a cell or a sub-array. See \xref{p.op.sizeof}
  for details.

\list{\lbullet}
  The empty instruction is an empty compound block, not a semicolon
  (\xref{p.stmt.empty}). This modification avoids a frequent error.

\list{\lbullet}
  The compiler directives differ from C's preprocessor commands. Notably,
  the |#define| directive is incompatible with that of C/\Cpp, and |#ifdef| and
  |#ifndef| are replaced by the more general |#if| directive (see
  ``Directives'' on \xref{p.directives}). To create numeric constants,
  see also \xref{p.const}; to create string constants, see also \xref{p.string.constant}.

\list{\lbullet}
  \codeidx{\#define}
  Text substitutions (preprocessor macros; see the |#define| directive) are not
  matched {\it across\/} lines. That is, the text that you want to match and
  replace with a |#define| macro {\it must\/} appear on a single line. The
  definition of a |#define| macro must also appear on a single line.

\list{\lbullet}
  The direction for truncation for the operator |/| is always towards the
  smaller value, where -2 is smaller than -1. The |%| operator always gives
  a positive result, regardless of the signs of the operands.
  See \xref{p.op.arithmetic}.

\list{\lbullet}
  There is no unary |+| operator, which is a ``no-operation'' operator anyway.

\list{\lbullet}
  \nameidx{Ritchie, Dennis}
  Three of the bitwise operators have different precedence than in C. The
  precedence levels of the |&|, |^| and {\tt \vbar} operators is higher than
  the relational operators (Dennis Ritchie explained that these operators got
  their low precedence levels in C because early C compilers did not yet have
  the logical |&&| and {\tt \vbar\vbar} operators, so the bitwise |&| and
  {\tt \vbar} were used instead).

\list{\lbullet}
  The ``extern'' keyword does not exist in \Small; the current implementation
  of the compiler has no ``linking phase''. To create a program from several
  source files, create one main project script file that ``|#include|'s'' all
  other source files. The \Small\ compiler can optimize out functions and global
  variables that you do not use. See pages \xrefn{p.stock.vars} and
  \xrefn{p.stock.funcs} for details.

\list{\lbullet}
  In most situations, forward declarations of functions (i.e., prototypes) are
  not necessary. \Small\ is a two-pass compiler, it will see all functions on the
  first pass and use them in the second pass. User-defined operators must be
  declared before use, however.

  If provided, forward declarations must match {\it exactly\/} with the
  function definition, parameter names may not be omitted from the prototype
  or differ from the function definition.
  \Small\ cares about parameter names in prototypes because of the
  ``named parameters'' feature. One uses prototypes to call forwardly declared
  functions. When doing so with named parameters, the compiler must already
  know the names of the parameters (and their position in the parameter list).
  As a result, the parameter names in a prototype must be equal to the ones in
  the definition.
\endlist


\chapter{Assorted tips}

\subsection{Working with characters and strings}
\xrdef{p.tips.strings}
\sidx{Packed string} \sidx{Unpacked string} \sidx{String}[packed \midtilde] \sidx{String}[unpacked \midtilde]

Strings can be in packed or in unpacked format. In the packed format, each
cell will typically hold four characters (in the current implementations, a
cell is 32-bit and a character is often 8 bit). In this configuration, the
first character in a ``pack'' of four is the highest byte of a cell and the
fourth character is in the lowest byte of each cell.

A string must be stored in an array. For an unpacked string, the array must be
large enough to hold all characters in the string plus a terminating zero cell.
That is, in the example below, the variable |ustring| is defined as having
five cells, which is just enough to contain the string with which it is
initialized:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new ustring[5] = "test"
|endverbatim\endlistingx

In a packed string, each cell contains several characters and the string ends
with a zero character. The |char| operator helps with declaring the array
size to contain the required number of {\it characters\/}. The example below
will allocate enough cells to hold five packed characters. In a typical
implementation, there will be two cells in the array.
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new pstring[5 char] = !"test"
|endverbatim\endlistingx

In other words, the |char| operators divides its left operand by the number
of bytes that fit in a cell and rounds upwards. Again, in a typical
implementation, this means dividing by four and rounding upwards.

You can design routines that work on strings in both packed and unpacked
formats. To find out whether a string is packed or unpacked, look at the
first cell of a string. If its value is either negative or higher than the
maximum possible value of a character (higher than 255 for 8 bit characters),
the string is a packed string. Otherwise it is an unpacked string.

\noindent\marginbox{-10}{See also page \xrefn{p.functions.proposed} for proposed core
functions that operate on both packed and unpacked strings}%
The code snippet below returns |true| if the input string is packed and |false|
otherwise:
\codeidx{ispacked}
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
bool: ispacked(string[])
    return !(charmin <= string[0] <= charmax)
|endverbatim\endlistingx

An unpacked string ends with a full zero cell. The end of a packed string is
marked with only a zero character. Since there may be up to four characters
in a cell, this zero character may occur at any of the four positions in
the ``pack''. The |{ }| operator extracts a character from a cell in an
array. Basically, one uses the cell index operator (``|[ ]|'') for
unpacked strings and the character index operator (``|{ }|'') to work on
packed strings.

\noindent\marginbox{0}{EOS: predefined constant to mark the End Of String; it has the value '\BS 0'}%
For example, a routine that returns the length in characters of any string
(packed or unpacked) is:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
my_strlen(string[])
    {
    new len = 0
    if (ispacked(string))
        while (string{len} != EOS)      /* get character from pack */
            ++len
    else
        while (string[len] != EOS)      /* get cell */
            ++len
    return len
    }
|endverbatim\endlistingx

If you make functions to work exclusively on either packed or unpacked strings,
it is a good idea to add an assertion to enforce this condition:
\codeidx{strupper}
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
strupper(string[])
    {
    assert ispacked(string)

    for (new i=0; string{i} != EOS; ++i)
        string{i} = toupper(string{i})
    }
|endverbatim\endlistingx

Although, in preceding paragraphs we have assumed that a cell is 32 bits wide
and a character is 8 bits, this cannot be relied upon.
\marginbox0{Predefined constants: \xrefn{p.predefined.constants}}%
The size of a cell is implementation defined; the maximum and minimum values
are in the predefined constants |cellmax| and |cellmin|. There are similar
predefined constants for characters. One may safely assume, however,
that both the size of a character in bytes and the size of a cell in bytes
are powers of two.

The |char| operator allows you to determine how many packed characters fit in
a cell. For example:

\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
#if     4 char == 1
        /* code that assumes 4 packed characters per cell */
#else
  #if   4 char == 2
        /* code that assumes 2 packed characters per cell */
  #else
    #if 4 char == 4
        /* code that assumes 1 packed character per cell */
    #else
        #assert 0 /* unsupported cell/character size */
    #endif
  #endif
#endif
|endverbatim\endlistingx

\subsection{Working with tags}
%-----------------------------
\xrdef{p.tips.tags} \sidx{Tag name} \sidx{Diagnostic}
\noindent\marginbox0{Tag names: \xrefn{p.tagnames}}%
The tag name system was invented to add a ``usage checking'' mechanism to \Small.
A tag denotes a ``purpose'' of a value or variable, and the \Small\ compiler
issues a diagnostic message when the tag of an expression does not match the
required tag for the context of the expression.

Many modern computer languages offer variable {\it types}, where a type
specifies the memory layout and the purpose of the variable. The programming
language then checks the type equivalence; the \smallcaps{pascal} language
is very strict at checking type equality, whereas the C programming language is
more forgiving. The \Small\ language does not have types: all variables have the
size and the layout of a cell, although bit representations in the cell may
depend on the purpose of the variable. In summary:
\beginlist{1em}\compactlist
\list{\lbullet} a type specifies the {\it memory layout\/} and the range of
  variables and function results
\list{\lbullet} a tagname labels the {\it purpose\/} of variables, constants and
  function results
\endlist \goodbreak

\sidx{User-defined operators}\sidx{Operators}[user-defined \midtilde]
\noindent\marginbox0{User-defined operators: \xrefn{p.user.opers}}%
Tags in \Small\ are mostly optional. A program that was ``fortified'' with tag
names on the variable and constant declarations will function identically when
all tag names are removed. One exception is formed by user-defined operators:
the \Small\ compiler uses the tags of the operands to choose between any user-defined
operators and the standard operator.

\goodbreak
The snippet below declares three variables and does three assignments, two of
which give a ``tag mismatch'' diagnostic message:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
new apple:elstar        /* variable "elstar" with tag "apple" */
new orange:valencia     /* variable "valencia" with tag "orange" */
new x                   /* untagged variable "x" */

elstar = valencia       /* tag mismatch */
elstar = x              /* tag mismatch */
x = valencia            /* ok */
|endverbatim\endlistingx

\sidx{Tag name}[weak \midtilde]
\noindent\marginbox0{More tag name rules: \xrefn{p.tagnames}}%
The first assignment causes a ``tag mismatch'' diagnostic as it assigns an
``orange'' tagged variable to a variable with an ``apple'' tag. The second
assignment puts the untagged value of |x| into a tagged variable, which causes
again a diagnostic. When the untagged variable is on the left hand of the
assignment operator, as in the third assignment, there is no warning or
error message. As variable |x| is untagged, it can accept a value of any weak
tag.

The same mechanism applies to passing variables or expressions to functions
as function operands ---see \xref{p.tag.arguments} for an example. In short,
when a function expects a particular tag name on an argument, you must pass an
expression\slash variable with a matching tag to that function; but if the
function expects an {\it un\/}tagged argument, you may pass in argments with
{\it any\/} weak tag.

On occasion, it is necessary to temporarily change the tag of an expression.
For example, with the declarations of the previous code snippet, if you would
wish to compare apples with oranges (recent research indicates that comparing
apples to oranges is not as absurd than popular belief holds), you could use:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
if (apple:valencia < elstar)
    valencia = orange:elstar
|endverbatim\endlistingx

\sidx{Tag name}[override@\midtilde\ override] \sidx{lvalue}
The test expression of the |if| statement (between parentheses) compares the
variable |valencia| to the variable |elstar|. To avoid a ``tag mismatch''
diagnostic, it puts a tag override |apple:| on |valencia| ---after that, the
expressions on the left and the right hands of the |>| operator have the same
tag name: ``|apple:|''.
\marginbox0{lvalue (definition of \midtilde): \xrefn{p.lvalue}}%
The second line, the assignment of |elstar| to |valencia|, overrides the tag
name of |elstar| or |orange:| before the assignment. In an assignment, you
cannot override the tag name of the destination; i.e., the left hand of the |=|
operator. It is an error to write ``|apple:valencia = elstar|''. In the
assignment, |valencia| is an ``lvalue'' and you cannot override the tag name of
an lvalue.

\sidx{lvalue}
As shown earlier, when the left hand of an assignment holds an untagged variable,
the expression on the right hand may have any waek tag name. When used as an
lvalue, an untagged variable is compatible with all weak tag names. Or rather,
a weak tag is silently dropped when it is assigned to an untagged variable or
when it is passed to a function that expects an untagged argument. When a
tag name indicates the bit pattern of a cell, silently dropping a weak tag can
hide errors. For example, the snippet below has an error that is not immediately
obvious:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
#pragma rational float

new limit = -5.0
new value = -1.0

if (value < limit)
    printf("Value %f below limit %f\n", value, limit)
else
    printf("Value above limit\n")
|endverbatim\endlistingx

Through the ``|#pragma rational|'', all rational numbers receive the ``|float|''
tag name and these numbers are encoded in the 4-byte IEEE 754 format. The
snippet declares two variables, |limit| and |value|, both of which are
{\it un\/}tagged (this is the error). Although the literal values |-5.0| and
|-1.0| are implicitly tagged with |float:|, this weak tag is silently
dropped when the values get assigned to the untagged symbols |limit| and |value|.
Now, the |if| statement compares |value| to |limit| as integers, using the
built-in standard |<| operator (a user-defined operator would be more
appropriate to compare two IEEE 754 encoded values). When run, this code snippet
tells us that ``|Value -1.000000 below limit -5.000000|'' ---which is incorrect,
of course.

\sidx{Tag name}[strong \midtilde]
To avoid such subtle errors to go undetected, one should use {\it strong\/}
tags. A strong tag is merely a tag name that starts with an upper case letter,
such as |Float:| instead of |float:|. A strong tag is never automatically
``dropped'', but it may still be explicitly overridden. Below is a modified
code snippet with the proposed adaptions:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
#pragma rational Float

new Float:limit = -5.0
new Float:value = -1.0

if (value < limit)
    printf("Value %f below limit %f\n", _:value, _:limit)
else
    printf("Value above limit\n")
|endverbatim\endlistingx

Forgetting the |Float:| tag name in the declaration of the variables |limit|
or |value| immediately gives a ``tag mismatch'' diagnostic, because the literal
values |-5.0| and |-1.0| now have a strong tag name.

\sidx{Tag name}[untag override] \sidx{Untag override}
|printf| is a general purpose function that can print strings and values in
various formats. To be general purpose, |printf| accepts arguments with any
weak tag name, be it |apple:|'s, |orange:|'s, or soemthing else. The |printf|
function does this by accepting untagged arguments ---weak tags are dropped
when an untagged argument is expected. Strong tags, however, are never dropped,
and in the above snippet, I needed to put an empty tag override, ``|_:|'',
before the variables |value| and |limit| in the first |printf| call.

There is an alternative to untagging expressions with strong tag names in
general purpose functions: adjust the definition of the function to accept
both all weak tags and a selective set of strong tag names. The \Small\ language
supports multiple tag names for every function arguments. The original defintion
of |printf| (from the file \smallcaps{console.inc}) is:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
native printf(const format[], ...);
|endverbatim\endlistingx

\sidx{Plural tag names} \sidx{Tag name}[plural tags]
By adding both a |Float:| tag and an empty tag in front of the ellipsis (``|...|''),
|printf| will accept arguments with the |Float:| tag name, arguments without a
tag name and arguments that have a weak tag name. To specify plural tag names,
enclose all tag names without their final colon between braces with a comma
separating the tag names (see the example below). It is necessary to add the
empty tag specification to the list of tag names, because |printf| would
otherwise {\it only\/} accept arguments with a |Float:| tag name. Below is the
new definition of the function |printf|:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
native printf(const format[], {Float, _}: ...);
|endverbatim\endlistingx

Plural tags allow you to write a single function that accepts cells with a
precisely specified subset of tags (strong and\slash or weak). While a function
argument may accept being passed {\it actual\/} arguments with diverse tags,
a variable can only have a single tag ---and a {\it formal\/} function argument
is a local variable in the body of the function. In the presence of plural tags,
the formal function argument takes on the tag that is listed first.

\sidx{Plural tag names} \sidx{Tag name}[plural tags] \sidx{Tag name}[operator@\midtilde\ operator]
On occasion, you may want to check which tag an {\it actual\/} function argument
had, when the argument accepts plural tags. Checking the tag of the formal argument
(in the body of the function) is of no avail, because it will always have the
first tag in the tag list in the declaration of the function argument. You can
check the tag of the actual argument by adding an extra argument to the function,
and set its default value to be the ``|tagof|'' of the argument in question.
\marginbox0{Directives: \xrefn{p.default.args.sizeof}}%
Similar to the |sizeof| operator, the |tagof| operator has a special meaning
when it is applied in a default value of a function argument: the expression
is evaluated at the point of the function {\it call}, instead of at the function
definition. This means that the ``default value'' of the function argument is
the actual tag of the parameter passed to the function.

Inside the body of the function, you can compare the tag to known tags by, again,
using the |tagof| operator.

%??? example

\subsection{Concatenating lines}
%-------------------------------
\noindent\marginbox0{Directives: \xrefn{p.directives}}%
\Small\ is a free format language, but the parser directives must be on a single
line. Strings may not run over several lines either. When this is
inconvenient, you can use a backslash character (``|\|'') at the end of a line
to ``glue'' that line with the next line.

\goodbreak
For example:
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
#define max_path        max_drivename + max_directorystring + \
                        max_filename + max_extension
|endverbatim\endlistingx

You also use the concatenation character to cut long literal strings over
multiple lines. Note that the ``|\|'' eats up all trailing white space that
comes after it and leading white space on the next line. The example below
prints ``Hello world'' with one space between the two words (because there is
a space between ''Hello'' and the backslash):
\listingx\verbatim|parskip=0pt|smalltt|compactverbatim|Ccode
print("Hello \
      world")
|endverbatim\endlistingx

\subsection{A program that generates its own source code}
%--------------------------------------------------------
An odd, slightly academic, criterion to quantify the ``expressiveness'' of a programming
language is size of the smallest program that, upon execution, regenerates its
own source code. The rationale behind this criterion is that the shorter the
self-generating program, the more flexible and expressive the language must be.
Programs of this kind have been created for many programming languages ---sometimes
surprisingly small, as for languages that have a built-in reflective capabilities.

\sidx{Quine} \nameidx{Van Orman Quine, Willard} \nameidx{Hofstadter, Douglas R.} \sidx{G\"odel, Escher, Bach}
Self-generating programs are called ``quines'', in honor of the philosopher
Willard Van Orman Quine who wrote self-creating phrases in natural language. The
work of Van Orman Quine became well known through the books ``G\"odel, Escher,
Bach'' and ``Metamagical Themas'' by Douglas Hofstadter.

The \Small\ quine is in the example below; it is modelled after the famous ``C''
quine (of which many variations exist). At 77 characters, it is amongst the
smallest versions for the class of imperative programming languages, and the size
can be reduced to 73 characters by removing four ``space'' characters that were
left in for readability.

\xrdef{p.ex.self}
\bigskip\listfile{../examples/self.sma}
\verbatim|parskip=0pt|smalltt|Ccode|dofile|endverbatim\endlistingx
